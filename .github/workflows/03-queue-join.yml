name: 03 - Queue Join and Wait

on:
  workflow_call:
    inputs:
      trigger_output:
        description: "Trigger workflow output data"
        required: true
        type: string
      trigger_type:
        description: "Trigger type (issue or workflow_dispatch)"
        required: true
        type: string
      build_id:
        description: "Build ID"
        required: true
        type: string
    outputs:
      join_success:
        description: "Whether join was successful"
        value: ${{ jobs.queue_join.outputs.join_success }}
      queue_position:
        description: "Position in queue"
        value: ${{ jobs.queue_join.outputs.queue_position }}

jobs:
  queue_join:
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join.outputs.join_success }}
      queue_position: ${{ steps.join.outputs.queue_position }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup data
        id: setup
        run: |
          # 使用输入参数
          TRIGGER_OUTPUT='${{ inputs.trigger_output }}'
          TRIGGER_TYPE='${{ inputs.trigger_type }}'
          BUILD_ID='${{ inputs.build_id }}'
          
          if [ -z "$TRIGGER_OUTPUT" ]; then
            echo "❌ No trigger output provided"
            exit 1
          fi
          
          echo "TRIGGER_OUTPUT=$TRIGGER_OUTPUT" >> $GITHUB_ENV
          echo "TRIGGER_TYPE=$TRIGGER_TYPE" >> $GITHUB_ENV
          echo "BUILD_ID=$BUILD_ID" >> $GITHUB_ENV
          
          # 获取触发方式
          if [ "$TRIGGER_TYPE" = "workflow_dispatch" ]; then
            echo "QUEUE_LIMIT=5" >> $GITHUB_ENV
          else
            echo "QUEUE_LIMIT=3" >> $GITHUB_ENV
          fi
      
      - name: Extract data
        id: extract
        run: |
          # 从trigger阶段获取数据
          INPUT='${{ env.TRIGGER_OUTPUT }}'
          
          # 验证输入JSON格式
          echo "Validating input JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # 设置环境变量供后续步骤使用
          echo "CURRENT_DATA=$INPUT" >> $GITHUB_ENV
          
      - name: Join queue with auto cleanup and wait
        id: join
        env:
          GITHUB_TOKEN: ${{ secrets.ISSUE_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
        run: |
          # 加载共享工具函数
          source .github/workflows/shared/github-utils.sh
          
          echo "Starting queue join process with auto cleanup..."
          
          # 重试机制参数
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          # 重试加入队列
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES to join queue..."
            
            QUEUE_MANAGER_ISSUE="1"
            QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
            echo "DEBUG: Raw queue manager content length: $(echo "$QUEUE_MANAGER_CONTENT" | wc -c)"
            QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
            echo "DEBUG: Extracted queue data: '$QUEUE_DATA'"
            
            # 如果解析JSON失败，直接重置
            if [ -z "$QUEUE_DATA" ] || ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
              echo "❌ JSON parsing failed, resetting queue template"
              echo "DEBUG: Failed queue data: '$QUEUE_DATA'"
              reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "JSON解析失败，重置为默认模板"
              QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
              QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
              echo "DEBUG: After reset, queue data: '$QUEUE_DATA'"
            fi
            
            # 获取当前状态
            CURRENT_VERSION=$(echo "$QUEUE_DATA" | jq -r '.version // 1')
            LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
            QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
            
            echo "Current version: $CURRENT_VERSION"
            echo "Lock run_id: $LOCK_RUN_ID"
            echo "Queue: $QUEUE"
            
            # === 自动清理逻辑 ===
            NEED_CLEANUP=false
            CLEANUP_REASONS=()
            
            # 1. 检查锁超时（超过2小时）
            if [ "$LOCK_RUN_ID" != "null" ]; then
              LOCK_ISSUE_JOIN_TIME=$(echo "$QUEUE" | \
                jq -r --arg run_id "$LOCK_RUN_ID" \
                '.[] | select(.issue_number == $run_id) | .join_time // empty' 2>/dev/null || echo "")
              
              if [ -n "$LOCK_ISSUE_JOIN_TIME" ]; then
                JOIN_TIMESTAMP=$(date -d "$LOCK_ISSUE_JOIN_TIME" +%s 2>/dev/null || echo "0")
                CURRENT_TIMESTAMP=$(date +%s)
                LOCK_DURATION_HOURS=$(( (CURRENT_TIMESTAMP - JOIN_TIMESTAMP) / 3600 ))
                
                if [ "$LOCK_DURATION_HOURS" -ge 2 ]; then
                  NEED_CLEANUP=true
                  CLEANUP_REASONS+=("锁超时：已占用${LOCK_DURATION_HOURS}小时")
                  echo "❌ Lock timeout: ${LOCK_DURATION_HOURS} hours"
                fi
              else
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("锁异常：找不到锁持有时间")
                echo "❌ Lock anomaly: no join time found"
              fi
            fi
            
            # 2. 检查重复项
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              DUPLICATE_ITEMS=$(echo "$QUEUE" | \
                jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number' 2>/dev/null || echo "")
              
              if [ -n "$DUPLICATE_ITEMS" ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("队列重复：构建项目 $DUPLICATE_ITEMS 重复")
                echo "❌ Duplicate items: $DUPLICATE_ITEMS"
              fi
            fi
            
            # 3. 检查无效issue
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              INVALID_ISSUES=()
              for issue_number in $(echo "$QUEUE" | jq -r '.[].issue_number'); do
                ISSUE_RESPONSE=$(curl -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/issues/$issue_number")
                
                if echo "$ISSUE_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  INVALID_ISSUES+=("$issue_number")
                  echo "❌ Issue #$issue_number not found"
                fi
              done
              
              if [ ${#INVALID_ISSUES[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("无效issue：${INVALID_ISSUES[*]} 不存在")
                echo "❌ Invalid issues: ${INVALID_ISSUES[*]}"
              fi
            fi
            
            # 4. 检查已结束的runs
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              EXPIRED_RUNS=()
              for run_id in $(echo "$QUEUE" | jq -r '.[] | select(.trigger_type == "workflow_dispatch") | .issue_number'); do
                # 检查workflow run是否存在且未完成
                RUN_RESPONSE=$(curl -s \
                  -H "Authorization: token $GITHUB_TOKEN" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/$GITHUB_REPOSITORY/actions/runs/$run_id")
                
                if echo "$RUN_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  EXPIRED_RUNS+=("$run_id")
                  echo "❌ Run #$run_id not found"
                else
                  # 检查run状态：completed, cancelled, failure, skipped 都是已结束状态
                  RUN_STATUS=$(echo "$RUN_RESPONSE" | jq -r '.status // "unknown"')
                  RUN_CONCLUSION=$(echo "$RUN_RESPONSE" | jq -r '.conclusion // "unknown"')
                  
                  if [ "$RUN_STATUS" = "completed" ] || [ "$RUN_STATUS" = "cancelled" ] || [ "$RUN_STATUS" = "failure" ] || [ "$RUN_STATUS" = "skipped" ]; then
                    EXPIRED_RUNS+=("$run_id")
                    echo "❌ Run #$run_id ended with status: $RUN_STATUS, conclusion: $RUN_CONCLUSION"
                  fi
                fi
              done
              
              if [ ${#EXPIRED_RUNS[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("已结束runs：${EXPIRED_RUNS[*]} 已完成/取消/失败/跳过或不存在")
                echo "❌ Expired runs: ${EXPIRED_RUNS[*]}"
              fi
            fi
            
            # 执行清理
            if [ "$NEED_CLEANUP" = true ]; then
              echo "Performing queue cleanup..."
              echo "Cleanup reasons: ${CLEANUP_REASONS[*]}"
              
              # 构建清理原因文本
              CLEANUP_REASON_TEXT=""
              for reason in "${CLEANUP_REASONS[@]}"; do
                CLEANUP_REASON_TEXT="${CLEANUP_REASON_TEXT}- $reason
              "
              done
              
              # 使用工具函数清理队列数据
              if cleanup_queue_data "$QUEUE_MANAGER_ISSUE" "$CLEANUP_REASON_TEXT" "$CURRENT_VERSION" "$QUEUE_DATA" "${INVALID_ISSUES[@]}" "${EXPIRED_RUNS[@]}"; then
                echo "✅ Queue cleanup successful on attempt $attempt"
                # 重新获取清理后的队列数据
                QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
                
                # 调试：输出清理后的数据
                echo "After cleanup - QUEUE_DATA: $QUEUE_DATA"
                echo "After cleanup - QUEUE: $QUEUE"
              else
                echo "❌ Queue cleanup failed on attempt $attempt"
                if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                  echo "Retrying in $RETRY_DELAY seconds..."
                  sleep $RETRY_DELAY
                  continue
                else
                  echo "Max retries reached, triggering queue reset..."
                  reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "清理失败，重置队列"
                  QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                  QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                  QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
                  
                  # 调试：输出重置后的数据
                  echo "After reset - QUEUE_DATA: $QUEUE_DATA"
                  echo "After reset - QUEUE: $QUEUE"
                fi
              fi
            else
              echo "No cleanup needed, queue is healthy"
            fi
            
            # === 加入队列逻辑 ===
            echo "Joining build queue..."
            
            # 检查队列长度限制
            QUEUE_LENGTH=$(echo "$QUEUE" | jq 'length // 0')
            QUEUE_LIMIT="${{ env.QUEUE_LIMIT }}"
            
            echo "Queue length: $QUEUE_LENGTH, Limit: $QUEUE_LIMIT"
            
            # 确保QUEUE_LENGTH是数字
            if [ -z "$QUEUE_LENGTH" ] || ! [[ "$QUEUE_LENGTH" =~ ^[0-9]+$ ]]; then
              QUEUE_LENGTH=0
              echo "Fixed queue length to: $QUEUE_LENGTH"
            fi
            
            if [ "$QUEUE_LENGTH" -ge "$QUEUE_LIMIT" ]; then
              echo "❌ Queue is full (limit: $QUEUE_LIMIT)"
              
              # 添加拒绝评论
              REJECT_COMMENT="## ❌ 构建被拒绝

              **拒绝原因：** 构建队列已满（当前 $QUEUE_LENGTH/$QUEUE_LIMIT）
              
              **当前队列：**
              $(echo "$QUEUE" | jq -r '.[] | "• #\(.issue_number) - \(.customer) (\(.join_time))"')
              
              **建议：** 请稍后重试或联系管理员
              **时间：** $(date '+%Y-%m-%d %H:%M:%S')"
              
              # 获取原始issue编号
              ORIGINAL_ISSUE_NUMBER="${{ env.BUILD_ID }}"
              
              if [ -n "$ORIGINAL_ISSUE_NUMBER" ]; then
                add_issue_comment_if_issue_trigger "${{ env.TRIGGER_TYPE }}" "${{ env.BUILD_ID }}" "$REJECT_COMMENT"
              fi
              
              echo "join_success=false" >> $GITHUB_OUTPUT
              echo "queue_position=-1" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # 检查是否已经在队列中
            EXISTING_ITEM=$(echo "$QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" '.[] | select(.build_id == $build_id) | .issue_number // empty')
            
            if [ -n "$EXISTING_ITEM" ]; then
              echo "⚠️ Already in queue at position: $EXISTING_ITEM"
              
              # 计算队列位置
              QUEUE_POSITION=$(echo "$QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" 'index(.[] | select(.build_id == $build_id)) + 1')
              
              echo "join_success=true" >> $GITHUB_OUTPUT
              echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # 准备新队列项数据
            CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            BUILD_TITLE="Custom Rustdesk Build"
            
            # 从trigger数据中提取信息
            TRIGGER_DATA='${{ env.CURRENT_DATA }}'
            
            # 调试：输出TRIGGER_DATA
            echo "TRIGGER_DATA: $TRIGGER_DATA"
            
            # 处理双重转义的JSON字符串
            # 如果输入是字符串形式的JSON，需要先解析
            if [[ "$TRIGGER_DATA" == \"*\" ]]; then
              echo "Detected string-wrapped JSON, parsing..."
              PARSED_TRIGGER_DATA=$(echo "$TRIGGER_DATA" | jq -r .)
              echo "Parsed TRIGGER_DATA: $PARSED_TRIGGER_DATA"
            else
              PARSED_TRIGGER_DATA="$TRIGGER_DATA"
            fi
            
            # 验证TRIGGER_DATA是否为有效JSON
            if ! echo "$PARSED_TRIGGER_DATA" | jq . > /dev/null 2>&1; then
              echo "❌ TRIGGER_DATA is not valid JSON"
              echo "join_success=false" >> $GITHUB_OUTPUT
              echo "queue_position=-1" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            TAG=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.tag // empty')
            CUSTOMER=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.customer // empty')
            CUSTOMER_LINK=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.customer_link // empty')
            SLOGAN=$(echo "$PARSED_TRIGGER_DATA" | jq -r '.slogan // empty')
            
            # 调试：输出提取的值
            echo "Extracted values:"
            echo "TAG: '$TAG'"
            echo "CUSTOMER: '$CUSTOMER'"
            echo "CUSTOMER_LINK: '$CUSTOMER_LINK'"
            echo "SLOGAN: '$SLOGAN'"
            
            # 加密敏感参数
            # ENCRYPTION_KEY 已通过 env 传递，无需再赋值
            
            if [ -z "$ENCRYPTION_KEY" ]; then
              echo "❌ Encryption key not found in repository variables"
              echo "join_success=false" >> $GITHUB_OUTPUT
              echo "queue_position=-1" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # 加密敏感参数
            ENCRYPTED_EMAIL=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.email // empty')")
            ENCRYPTED_SUPER_PASSWORD=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.super_password // empty')")
            ENCRYPTED_RENDEZVOUS_SERVER=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.rendezvous_server // empty')")
            ENCRYPTED_RS_PUB_KEY=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.rs_pub_key // empty')")
            ENCRYPTED_API_SERVER=$(encrypt_params "$(echo "$PARSED_TRIGGER_DATA" | jq -r '.api_server // empty')")
            
            # 创建新的队列项
            NEW_QUEUE_ITEM=$(jq -c -n \
              --arg build_id "${{ env.BUILD_ID }}" \
              --arg build_title "$BUILD_TITLE" \
              --arg trigger_type "${{ env.TRIGGER_TYPE }}" \
              --arg tag "$TAG" \
              --arg customer "$CUSTOMER" \
              --arg customer_link "$CUSTOMER_LINK" \
              --arg slogan "$SLOGAN" \
              --arg join_time "$CURRENT_TIME" \
              --arg encrypted_email "$ENCRYPTED_EMAIL" \
              --arg encrypted_super_password "$ENCRYPTED_SUPER_PASSWORD" \
              --arg encrypted_rendezvous_server "$ENCRYPTED_RENDEZVOUS_SERVER" \
              --arg encrypted_rs_pub_key "$ENCRYPTED_RS_PUB_KEY" \
              --arg encrypted_api_server "$ENCRYPTED_API_SERVER" \
              '{build_id: $build_id, build_title: $build_title, trigger_type: $trigger_type, tag: $tag, customer: $customer, customer_link: $customer_link, slogan: $slogan, join_time: $join_time, encrypted_email: $encrypted_email, encrypted_super_password: $encrypted_super_password, encrypted_rendezvous_server: $encrypted_rendezvous_server, encrypted_rs_pub_key: $encrypted_rs_pub_key, encrypted_api_server: $encrypted_api_server}')
            
            # 添加到队列
            NEW_QUEUE=$(echo "$QUEUE" | jq --argjson new_item "$NEW_QUEUE_ITEM" '. + [$new_item]')
            
            # 更新队列数据
            NEW_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --argjson new_queue "$NEW_QUEUE" '.queue = $new_queue')
            
            # 更新队列管理issue
            NEW_QUEUE_DATA_SINGLE=$(echo "$NEW_QUEUE_DATA" | jq -c .)
            UPDATED_TOTAL_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | length // 0')
            UPDATED_ISSUE_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "issue")) | length // 0')
            UPDATED_WORKFLOW_COUNT=$(echo "$NEW_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "workflow_dispatch")) | length // 0')
            
            CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
            UPDATED_BODY="## 构建队列管理

            **最后更新时间：** $CURRENT_TIME

            ### 当前状态
            - **构建锁状态：** 空闲 🔓
            - **当前构建：** 无
            - **锁持有者：** 无
            - **版本：** $CURRENT_VERSION

            ### 构建队列
            - **当前数量：** $UPDATED_TOTAL_COUNT/5
            - **Issue触发：** $UPDATED_ISSUE_COUNT/3
            - **手动触发：** $UPDATED_WORKFLOW_COUNT/5

            ---

            ### 队列数据
            \`\`\`json
            $NEW_QUEUE_DATA_SINGLE
            \`\`\`
            "
            
            if update_queue_issue "$QUEUE_MANAGER_ISSUE" "$UPDATED_BODY"; then
              echo "✅ Successfully joined queue"
              
              # 计算队列位置
              QUEUE_POSITION=$(echo "$NEW_QUEUE" | jq 'length')
              
              # 添加成功评论
              SUCCESS_COMMENT="## ✅ 构建已加入队列

              **队列位置：** $QUEUE_POSITION/$QUEUE_LIMIT
              **构建ID：** ${{ env.BUILD_ID }}
              **标签：** $TAG
              **客户：** $CUSTOMER
              **标语：** $SLOGAN
              **加入时间：** $CURRENT_TIME
              
              **状态：** 等待构建中 ⏳
              **预计等待时间：** 约 $((QUEUE_POSITION * 30)) 分钟"
              
              # 获取原始issue编号
              ORIGINAL_ISSUE_NUMBER="${{ env.BUILD_ID }}"
              
              if [ -n "$ORIGINAL_ISSUE_NUMBER" ]; then
                add_issue_comment_if_issue_trigger "${{ env.TRIGGER_TYPE }}" "${{ env.BUILD_ID }}" "$SUCCESS_COMMENT"
              fi
              
              echo "join_success=true" >> $GITHUB_OUTPUT
              echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
              
              # === 等待队列逻辑 ===
              echo "Starting queue wait process..."
              
              # 等待直到轮到构建
              while true; do
                echo "Checking queue position..."
                
                # 重新获取队列状态
                QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                CURRENT_LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
                CURRENT_QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
                
                echo "DEBUG: QUEUE_DATA: $QUEUE_DATA"
                echo "DEBUG: CURRENT_QUEUE: $CURRENT_QUEUE"
                echo "$CURRENT_QUEUE" | jq .
                
                # 检查是否还在队列中
                CURRENT_QUEUE_POSITION=$(echo "$CURRENT_QUEUE" | jq -r --arg build_id "${{ env.BUILD_ID }}" 'index(.[] | select(.build_id == $build_id)) + 1')
                
                if [ "$CURRENT_QUEUE_POSITION" = "null" ] || [ -z "$CURRENT_QUEUE_POSITION" ]; then
                  echo "❌ Build removed from queue"
                  echo "join_success=false" >> $GITHUB_OUTPUT
                  echo "queue_position=-1" >> $GITHUB_OUTPUT
                  exit 1
                fi
                
                # 检查是否轮到构建（队列第一位且没有锁）
                if [ "$CURRENT_QUEUE_POSITION" = "1" ] && [ "$CURRENT_LOCK_RUN_ID" = "null" ]; then
                  echo "✅ It's our turn to build! Acquiring lock..."
                  # 抢锁：更新 run_id
                  UPDATED_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --arg run_id "${{ env.BUILD_ID }}" '.run_id = $run_id')
                  # 拼接新的正文
                  CURRENT_TIME=$(date '+%Y-%m-%d %H:%M:%S')
                  UPDATED_QUEUE_DATA_SINGLE=$(echo "$UPDATED_QUEUE_DATA" | jq -c .)
                  UPDATED_BODY="## 构建队列管理

                  **最后更新时间：** $CURRENT_TIME

                  ### 当前状态
                  - **构建锁状态：** 占用 🔒
                  - **当前构建：** Custom Rustdesk Build
                  - **锁持有者：** ${{ env.BUILD_ID }}
                  - **版本：** $(echo "$UPDATED_QUEUE_DATA" | jq -r '.version')

                  ### 构建队列
                  - **当前数量：** $(echo "$UPDATED_QUEUE_DATA" | jq '.queue | length // 0')/5
                  - **Issue触发：** $(echo "$UPDATED_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "issue")) | length // 0')/3
                  - **手动触发：** $(echo "$UPDATED_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "workflow_dispatch")) | length // 0')/5

                  ---

                  ### 队列数据
                  \`\`\`json
                  $UPDATED_QUEUE_DATA_SINGLE
                  \`\`\`
                  "
                  update_queue_issue "$QUEUE_MANAGER_ISSUE" "$UPDATED_BODY"
                  # 再次获取队列数据，确认锁已被自己持有
                  QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                  QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                  CURRENT_LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
                  if [ "$CURRENT_LOCK_RUN_ID" = "${{ env.BUILD_ID }}" ]; then
                    echo "✅ Lock acquired by current build."
                    break
                  else
                    echo "⚠️ Failed to acquire lock, retrying..."
                    sleep 3
                    continue
                  fi
                fi
                
                # 检查是否有锁但锁持有者不是我们
                if [ "$CURRENT_LOCK_RUN_ID" != "null" ] && [ "$CURRENT_LOCK_RUN_ID" != "${{ env.BUILD_ID }}" ]; then
                  echo "⏳ Another build is running (lock: $CURRENT_LOCK_RUN_ID), waiting..."
                else
                  echo "⏳ Waiting in queue position $CURRENT_QUEUE_POSITION..."
                fi
                
                # 等待30秒后再次检查
                sleep 30
              done
              
              echo "✅ Queue wait completed successfully"
              break
              
            else
              echo "❌ Failed to join queue"
              if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                echo "Retrying in $RETRY_DELAY seconds..."
                sleep $RETRY_DELAY
              else
                echo "Max retries reached"
                echo "join_success=false" >> $GITHUB_OUTPUT
                echo "queue_position=-1" >> $GITHUB_OUTPUT
                exit 1
              fi
            fi
          done 