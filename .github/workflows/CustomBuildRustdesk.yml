name: Custom Build Rustdesk

on:
  issues:
    types: [opened]
  workflow_dispatch:
    inputs:
      tag:
        description: "标签名称"
        required: false
        default: "vCustom"
        type: string
      email:
        description: "邮件地址"
        required: false
        default: "rustdesk@example.com"
        type: string
      customer:
        description: "客户名称"
        required: false
        default: "自由工作室"
        type: string
      customer_link:
        description: "客户链接"
        required: false
        default: "https://rustdesk.com"
        type: string
      super_password:
        description: "超级密码"
        required: false
        default: "123456"
        type: string
      slogan:
        description: "标语"
        required: false
        default: "安全可靠的远程桌面解决方案"
        type: string
      rendezvous_server:
        description: "服务器地址"
        required: false
        default: "1.2.3.4:21117"
        type: string
      rs_pub_key:
        description: "公钥"
        required: false
        default: "xxxxx"
        type: string
      api_server:
        description: "API服务器地址"
        required: false
        default: "https://api.example.com"
        type: string

# 添加权限配置
permissions:
  issues: write
  contents: read

jobs:
  trigger: # 触发阶段
    runs-on: ubuntu-latest
    outputs:
      trigger_output: ${{ toJson(steps.setup.outputs.data) }}
    steps:
      - name: Setup framework
        id: setup
        run: |
          echo "Preparing environment..."
          
          # 判断触发方式并提取参数
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 手动触发：使用workflow_dispatch输入参数
            echo "Manual trigger detected"
            TAG="${{ github.event.inputs.tag }}"
            EMAIL="${{ github.event.inputs.email }}"
            CUSTOMER="${{ github.event.inputs.customer }}"
            CUSTOMER_LINK="${{ github.event.inputs.customer_link }}"
            SUPER_PASSWORD="${{ github.event.inputs.super_password }}"
            SLOGAN="${{ github.event.inputs.slogan }}"
            RENDEZVOUS_SERVER="${{ github.event.inputs.rendezvous_server }}"
            RS_PUB_KEY="${{ github.event.inputs.rs_pub_key }}"
            API_SERVER="${{ github.event.inputs.api_server }}"
          else
            # Issue触发：从issue内容中提取参数
            echo "Issue trigger detected"
            ISSUE_BODY="${{ github.event.issue.body }}"
            
            # 使用grep和sed提取参数值
            TAG=$(echo "$ISSUE_BODY" | grep -oP 'tag:\s*\K[^\r\n]+' | head -1 || echo "")
            EMAIL=$(echo "$ISSUE_BODY" | grep -oP 'email:\s*\K[^\r\n]+' | head -1 || echo "")
            CUSTOMER=$(echo "$ISSUE_BODY" | grep -oP 'customer:\s*\K[^\r\n]+' | head -1 || echo "")
            CUSTOMER_LINK=$(echo "$ISSUE_BODY" | grep -oP 'customer_link:\s*\K[^\r\n]+' | head -1 || echo "")
            SUPER_PASSWORD=$(echo "$ISSUE_BODY" | grep -oP 'super_password:\s*\K[^\r\n]+' | head -1 || echo "")
            SLOGAN=$(echo "$ISSUE_BODY" | grep -oP 'slogan:\s*\K[^\r\n]+' | head -1 || echo "")
            RENDEZVOUS_SERVER=$(echo "$ISSUE_BODY" | grep -oP 'rendezvous_server:\s*\K[^\r\n]+' | head -1 || echo "")
            RS_PUB_KEY=$(echo "$ISSUE_BODY" | grep -oP 'rs_pub_key:\s*\K[^\r\n]+' | head -1 || echo "")
            API_SERVER=$(echo "$ISSUE_BODY" | grep -oP 'api_server:\s*\K[^\r\n]+' | head -1 || echo "")
          fi
          
          # 检查关键参数是否为空，如果为空则使用secrets兜底
          if [ -z "$RENDEZVOUS_SERVER" ] || [ -z "$RS_PUB_KEY" ]; then
            echo "Using secrets fallback for missing critical parameters"
            TAG="${TAG:-${{ secrets.DEFAULT_TAG }}}"
            EMAIL="${EMAIL:-${{ secrets.DEFAULT_EMAIL }}}"
            CUSTOMER="${CUSTOMER:-${{ secrets.DEFAULT_CUSTOMER }}}"
            CUSTOMER_LINK="${CUSTOMER_LINK:-${{ secrets.DEFAULT_CUSTOMER_LINK }}}"
            SUPER_PASSWORD="${SUPER_PASSWORD:-${{ secrets.DEFAULT_SUPER_PASSWORD }}}"
            SLOGAN="${SLOGAN:-${{ secrets.DEFAULT_SLOGAN }}}"
            RENDEZVOUS_SERVER="${RENDEZVOUS_SERVER:-${{ secrets.DEFAULT_RENDEZVOUS_SERVER }}}"
            RS_PUB_KEY="${RS_PUB_KEY:-${{ secrets.DEFAULT_RS_PUB_KEY }}}"
            API_SERVER="${API_SERVER:-${{ secrets.DEFAULT_API_SERVER }}}"
          fi
          
          # 生成初始JSON数据
          DATA=$(jq -c -n \
            --arg tag "$TAG" \
            --arg email "$EMAIL" \
            --arg customer "$CUSTOMER" \
            --arg customer_link "$CUSTOMER_LINK" \
            --arg super_password "$SUPER_PASSWORD" \
            --arg slogan "$SLOGAN" \
            --arg rendezvous_server "$RENDEZVOUS_SERVER" \
            --arg rs_pub_key "$RS_PUB_KEY" \
            --arg api_server "$API_SERVER" \
            '{tag: $tag, email: $email, customer: $customer, customer_link: $customer_link, super_password: $super_password, slogan: $slogan, rendezvous_server: $rendezvous_server, rs_pub_key: $rs_pub_key, api_server: $api_server}')
          
          # 存储输出
          echo "data=$DATA" >> $GITHUB_OUTPUT
      
      - name: Overwrite issue content
        if: github.event_name == 'issues'
        run: |
          # 创建清理后的issue内容
          CLEANED_BODY="## 构建请求已处理

          **构建参数：**
          - 标签: ${{ fromJson(steps.setup.outputs.data).tag }}
          - 客户: ${{ fromJson(steps.setup.outputs.data).customer }}
          - 标语: ${{ fromJson(steps.setup.outputs.data).slogan }}

          **状态：** 构建已启动
          **时间：** $(date '+%Y-%m-%d %H:%M:%S')

          ---
          *敏感信息已自动清理*"
          
          # 使用jq正确转义JSON
          JSON_PAYLOAD=$(jq -n --arg body "$CLEANED_BODY" '{"body": $body}')
          
          # 使用GitHub API更新issue
          curl -X PATCH \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }} \
            -d "$JSON_PAYLOAD"
      
      - name: Verify dependencies
        run: echo "Checking system dependencies"
      
      - name: Generate config
        run: |
          # 在同一个job中访问数据
          echo "Trigger type: ${{ github.event_name }}"
          echo "Tag: ${{ fromJson(steps.setup.outputs.data).tag }}"
          echo "Customer: ${{ fromJson(steps.setup.outputs.data).customer }}"
          echo "Rendezvous Server: ${{ fromJson(steps.setup.outputs.data).rendezvous_server }}"

  review: # 审核阶段
    needs: trigger
    runs-on: ubuntu-latest
    outputs:
      review_output: ${{ toJson(steps.output.outputs.data) }}
      build_approved: ${{ steps.output.outputs.build_approved }}
    steps:
      - name: Extract data
        id: extract
        run: |
          # 仅提取数据，不进行任何处理
          INPUT='${{ fromJson(needs.trigger.outputs.trigger_output) }}'
          
          # 提取服务器地址
          RENDEZVOUS_SERVER=$(echo "$INPUT" | jq -r '.rendezvous_server')
          API_SERVER=$(echo "$INPUT" | jq -r '.api_server')
          EMAIL=$(echo "$INPUT" | jq -r '.email')
          
          # 设置环境变量供后续步骤使用
          echo "RENDEZVOUS_SERVER=$RENDEZVOUS_SERVER" >> $GITHUB_ENV
          echo "API_SERVER=$API_SERVER" >> $GITHUB_ENV
          echo "EMAIL=$EMAIL" >> $GITHUB_ENV
          echo "CURRENT_DATA=$INPUT" >> $GITHUB_ENV
          
          # 验证JSON格式
          echo "Validating JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "JSON validation passed"
      
      - name: Auto reject invalid server parameters
        run: |
          # 检查是否为有效的IP或域名格式
          is_valid_ip() {
            [[ "$1" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}(:[0-9]+)?$ ]]
          }
          is_valid_domain() {
            [[ "$1" =~ ^([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(:[0-9]+)?$ ]]
          }
          is_valid_url() {
            local url="$1"
            url="${url#http://}"
            url="${url#https://}"
            is_valid_ip "$url" || is_valid_domain "$url"
          }
          is_email() {
            [[ "$1" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]
          }
          
          # 调试输出
          echo "Validating parameters:"
          echo "RENDEZVOUS_SERVER: $RENDEZVOUS_SERVER"
          echo "API_SERVER: $API_SERVER"
          echo "EMAIL: $EMAIL"
          
          AUTO_REJECT_REASON=""
          
          # 检查rendezvous_server格式
          if ! is_valid_ip "$RENDEZVOUS_SERVER" && ! is_valid_domain "$RENDEZVOUS_SERVER"; then
            AUTO_REJECT_REASON="${AUTO_REJECT_REASON}• rendezvous_server 格式无效: $RENDEZVOUS_SERVER
          "
            echo "❌ rendezvous_server format invalid"
          else
            echo "✅ rendezvous_server format valid"
          fi
          
          # 检查api_server格式
          if ! is_valid_url "$API_SERVER"; then
            AUTO_REJECT_REASON="${AUTO_REJECT_REASON}• api_server 格式无效: $API_SERVER
          "
            echo "❌ api_server format invalid"
          else
            echo "✅ api_server format valid"
          fi
          
          # 检查email（如果提供）
          if [ -n "$EMAIL" ] && ! is_email "$EMAIL"; then
            AUTO_REJECT_REASON="${AUTO_REJECT_REASON}• email 格式非法: $EMAIL
          "
            echo "❌ email validation failed"
          else
            echo "✅ email validation passed"
          fi
          
          # 去掉最后多余的空行
          AUTO_REJECT_REASON=$(echo "$AUTO_REJECT_REASON" | sed '/^$/d')
          
          if [ -n "$AUTO_REJECT_REASON" ]; then
            echo "自动拒绝原因：$AUTO_REJECT_REASON"
            REJECT_COMMENT="## ❌ 构建被自动拒绝

          **拒绝原因：**
          $AUTO_REJECT_REASON

          **时间：** $(date '+%Y-%m-%d %H:%M:%S')
          请检查参数后重新提交issue。"
            echo -e "$REJECT_COMMENT" | jq -Rs '{body: .}' | \
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
                -d @-
            echo "BUILD_REJECTED=true" >> $GITHUB_ENV
            exit 0
          else
            echo "✅ All parameter validations passed"
          fi

      - name: Determine review requirement
        if: env.BUILD_REJECTED != 'true'
        run: |
          # 默认需要审核
          NEED_REVIEW=true

          # 仓库所有者免审核
          if [ "${{ github.actor }}" = "${{ github.repository_owner }}" ]; then
            echo "Repo owner detected, skipping review."
            NEED_REVIEW=false
          fi

          # 检查是否为私有IP地址
          check_private_ip() {
            local input="$1"
            local ip="$input"
            
            # 移除协议前缀
            ip="${ip#http://}"
            ip="${ip#https://}"
            
            # 移除端口号（如果有）
            ip=$(echo "$ip" | cut -d: -f1)
            
            echo "Checking IP: $ip (from: $input)"
            
            # 检查10.0.0.0/8
            if [[ "$ip" =~ ^10\. ]]; then
              echo "✅ 10.x.x.x private IP detected"
              return 0
            fi
            
            # 检查172.16.0.0/12
            if [[ "$ip" =~ ^172\.(1[6-9]|2[0-9]|3[0-1])\. ]]; then
              echo "✅ 172.16-31.x.x private IP detected"
              return 0
            fi
            
            # 检查192.168.0.0/16
            if [[ "$ip" =~ ^192\.168\. ]]; then
              echo "✅ 192.168.x.x private IP detected"
              return 0
            fi
            
            echo "❌ Public IP or domain detected: $ip"
            return 1
          }
          
          # 检查两个服务器地址
          RENDEZVOUS_PRIVATE=false
          API_PRIVATE=false
          
          echo "Checking Rendezvous Server: $RENDEZVOUS_SERVER"
          if check_private_ip "$RENDEZVOUS_SERVER"; then
            RENDEZVOUS_PRIVATE=true
            echo "Rendezvous server is private IP: $RENDEZVOUS_SERVER"
          else
            echo "Rendezvous server is public IP or domain: $RENDEZVOUS_SERVER"
          fi
          
          echo "Checking API Server: $API_SERVER"
          if check_private_ip "$API_SERVER"; then
            API_PRIVATE=true
            echo "API server is private IP: $API_SERVER"
          else
            echo "API server is public IP or domain: $API_SERVER"
          fi
          
          # 判断是否需要审核
          if [ "$NEED_REVIEW" = "false" ]; then
            echo "Skipping review due to repo owner or private IP check."
          else
            if [ "$RENDEZVOUS_PRIVATE" = "true" ] && [ "$API_PRIVATE" = "true" ]; then
              NEED_REVIEW=false
              echo "Both servers are private IPs - no review needed"
            else
              NEED_REVIEW=true
              echo "At least one server is public IP - review required"
            fi
          fi
          
          # 设置审核标记到环境变量，供后续步骤使用
          echo "NEED_REVIEW=$NEED_REVIEW" >> $GITHUB_ENV
      
      - name: Handle review process
        if: env.NEED_REVIEW == 'true' && env.BUILD_REJECTED != 'true'
        run: |
          echo "Review required. Starting review process..."
          
          # 在issue中添加审核状态
          REVIEW_COMMENT="## 🔍 审核状态

          **需要审核原因：** 检测到公网IP地址或域名
          - Rendezvous Server: $RENDEZVOUS_SERVER
          - API Server: $API_SERVER

          **审核要求：** 请管理员回复 '同意构建' 或 '拒绝构建'

          **状态：** 等待审核中 ⏳
          **时间：** $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 使用jq正确转义JSON
          JSON_PAYLOAD=$(jq -n --arg body "$REVIEW_COMMENT" '{"body": $body}')

          # 添加审核评论
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
            -d "$(jq -n --arg body "$REVIEW_COMMENT" '{"body": $body}')"
          
          # 循环检查审核回复
          START_TIME=$(date +%s)
          TIMEOUT=7200  # 2小时超时
          APPROVED=false
          REJECTED=false # 新增变量，用于标记拒绝
          
          while [ $(($(date +%s) - START_TIME)) -lt $TIMEOUT ]; do
            echo "Checking for admin approval... ($(($(date +%s) - START_TIME))s elapsed)"
            
            # 获取issue的最新评论
            COMMENTS=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments)
            
            # 检查是否有管理员回复
            # 获取仓库所有者和管理员列表
            REPO_OWNER="${{ github.repository_owner }}"
            
            # 检查是否有管理员回复（包括仓库所有者）
            if echo "$COMMENTS" | jq -e --arg owner "$REPO_OWNER" '.[] | select(.user.login == $owner or .user.login == "admin" or .user.login == "管理员用户名") | select(.body | contains("同意构建"))' > /dev/null; then
              APPROVED=true
              break
            fi
            
            if echo "$COMMENTS" | jq -e --arg owner "$REPO_OWNER" '.[] | select(.user.login == $owner or .user.login == "admin" or .user.login == "管理员用户名") | select(.body | contains("拒绝构建"))' > /dev/null; then
              REJECTED=true
              break
            fi
            
            # 调试：输出最新的评论信息
            echo "Latest comments:"
            echo "$COMMENTS" | jq -r '.[-3:] | .[] | "User: \(.user.login), Body: \(.body[0:100])..."'
            
            # 等待30秒后再次检查
            sleep 30
          done
          
          if [ "$APPROVED" = true ]; then
            echo "Admin approval received"
            # 添加审核通过评论
            APPROVAL_COMMENT="## ✅ 审核通过
            **状态：** 审核已通过
            **审核人：** 管理员
            **时间：** $(date '+%Y-%m-%d %H:%M:%S')
            构建将继续进行..."
            
          # 使用jq正确转义JSON
          JSON_PAYLOAD=$(jq -n --arg body "$APPROVAL_COMMENT" '{"body": $body}')

            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d "$(jq -n --arg body "$APPROVAL_COMMENT" '{"body": $body}')"
          elif [ "$REJECTED" = true ]; then
            echo "Build rejected by admin"
            
            # 添加拒绝评论
            REJECT_COMMENT="## ❌ 构建被拒绝
            **状态：** 构建已被管理员拒绝
            **时间：** $(date '+%Y-%m-%d %H:%M:%S')
            构建流程已终止。如需重新构建，请重新提交issue。"
            
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d "$(jq -n --arg body "$REJECT_COMMENT" "{\"body\": \$body}")"
            
            echo "Build rejected by admin - setting build_approved to false"
            # 设置构建被拒绝标志
            echo "BUILD_REJECTED=true" >> $GITHUB_ENV
            exit 0
          else
            echo "Review timeout after 2 hours"
            # 添加超时评论
            TIMEOUT_COMMENT="## ⏰ 审核超时
            **状态：** 审核超时（2小时）
            **时间：** $(date '+%Y-%m-%d %H:%M:%S')
            构建将自动终止。如需重新构建，请重新提交issue。"
            
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d "$(jq -n --arg body "$TIMEOUT_COMMENT" "{\"body\": \$body}")"
            
            echo "Review timeout - setting build_approved to false"
            # 设置审核超时标志
            echo "BUILD_TIMEOUT=true" >> $GITHUB_ENV
            exit 0
          fi

      - name: Output data
        if: env.BUILD_REJECTED != 'true'
        id: output
        run: |
          # 重新获取原始数据并确保JSON格式正确
          INPUT='${{ fromJson(needs.trigger.outputs.trigger_output) }}'
          
          # 确保输出的是有效的JSON格式
          echo "data=$INPUT" >> $GITHUB_OUTPUT
          
          # 根据标志设置构建批准状态
          if [ "${{ env.BUILD_REJECTED }}" = "true" ]; then
            echo "build_approved=false" >> $GITHUB_OUTPUT
            echo "Build was rejected by admin"
          elif [ "${{ env.BUILD_TIMEOUT }}" = "true" ]; then
            echo "build_approved=false" >> $GITHUB_OUTPUT
            echo "Build timed out during review"
          else
            echo "build_approved=true" >> $GITHUB_OUTPUT
            echo "Build was approved or no review needed"
          fi
          
          # 显示输出信息
          echo "Review output: $INPUT"
          
          # 验证输出的JSON格式
          echo "Validating output JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "Output JSON validation passed"

  queue: # 排队阶段
    needs: review
    runs-on: ubuntu-latest
    if: needs.review.outputs.build_approved == 'true'
    outputs:
      queue_output: ${{ toJson(steps.output.outputs.data) }}
    steps:
      - name: Extract data
        id: extract
        run: |
          # 提取数据
          INPUT='${{ fromJson(needs.review.outputs.review_output) }}'
          
          # 验证输入JSON格式
          echo "Validating input JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # 设置环境变量供后续步骤使用
          echo "CURRENT_DATA=$INPUT" >> $GITHUB_ENV
          
          # 获取触发方式
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "TRIGGER_TYPE=workflow_dispatch" >> $GITHUB_ENV
            echo "QUEUE_LIMIT=5" >> $GITHUB_ENV
          else
            echo "TRIGGER_TYPE=issue" >> $GITHUB_ENV
            echo "QUEUE_LIMIT=3" >> $GITHUB_ENV
          fi

      - name: Auto cleanup queue
        run: |
          # 自动清理队列，处理异常锁和卡住的状态
          echo "Starting automatic queue cleanup..."
          
          QUEUE_MANAGER_ISSUE="1"
          QUEUE_MANAGER_CONTENT=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
          
          # 检查issue是否存在
          if echo "$QUEUE_MANAGER_CONTENT" | jq -e '.message' | grep -q "Not Found"; then
            echo "Queue manager issue #$QUEUE_MANAGER_ISSUE not found, skipping cleanup"
            echo "QUEUE_CLEANED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 解析队列数据
          QUEUE_DATA=$(echo "$QUEUE_MANAGER_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
          
          if [ -z "$QUEUE_DATA" ]; then
            echo "No queue data found, skipping cleanup"
            echo "QUEUE_CLEANED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # 验证JSON格式
          if ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
            echo "Invalid JSON format in queue data, skipping cleanup"
            echo "QUEUE_CLEANED=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "Current queue data: $QUEUE_DATA"
          
          # 获取当前状态
          CURRENT_BUILD=$(echo "$QUEUE_DATA" | jq -r '.current_build // null')
          LOCK_HOLDER=$(echo "$QUEUE_DATA" | jq -r '.lock_holder // null')
          ISSUE_QUEUE=$(echo "$QUEUE_DATA" | jq -r '.issue_queue // []')
          WORKFLOW_QUEUE=$(echo "$QUEUE_DATA" | jq -r '.workflow_queue // []')
          
          echo "Current build: $CURRENT_BUILD"
          echo "Lock holder: $LOCK_HOLDER"
          echo "Issue queue: $ISSUE_QUEUE"
          echo "Workflow queue: $WORKFLOW_QUEUE"
          
          # 检查是否需要清理
          NEED_CLEANUP=false
          CLEANUP_REASON=""
          
          # 1. 检查锁是否异常（有锁但没有持有者，或有持有者但没有锁）
          if [ "$CURRENT_BUILD" != "null" ] && [ "$LOCK_HOLDER" = "null" ]; then
            NEED_CLEANUP=true
            CLEANUP_REASON="${CLEANUP_REASON}• 锁异常：有构建项目但无持有者
          "
            echo "❌ Lock anomaly detected: build=$CURRENT_BUILD, holder=null"
          fi
          
          if [ "$CURRENT_BUILD" = "null" ] && [ "$LOCK_HOLDER" != "null" ]; then
            NEED_CLEANUP=true
            CLEANUP_REASON="${CLEANUP_REASON}• 锁异常：有持有者但无构建项目
          "
            echo "❌ Lock anomaly detected: build=null, holder=$LOCK_HOLDER"
          fi
          
          # 2. 检查锁是否长时间占用（超过2小时）
          if [ "$CURRENT_BUILD" != "null" ] && [ "$CURRENT_BUILD" != "null" ]; then
            # 获取锁持有时间（从队列项中查找）
            LOCK_ISSUE_JOIN_TIME=""
            if [ "$(echo "$ISSUE_QUEUE" | jq -r 'type')" = "array" ]; then
              LOCK_ISSUE_JOIN_TIME=$(echo "$ISSUE_QUEUE" | \
                jq -r --arg issue_number "$CURRENT_BUILD" \
                '.[] | select(.issue_number == $issue_number) | .join_time // empty')
            fi
            
            if [ "$(echo "$WORKFLOW_QUEUE" | jq -r 'type')" = "array" ]; then
              if [ -z "$LOCK_ISSUE_JOIN_TIME" ]; then
                LOCK_ISSUE_JOIN_TIME=$(echo "$WORKFLOW_QUEUE" | \
                  jq -r --arg issue_number "$CURRENT_BUILD" \
                  '.[] | select(.issue_number == $issue_number) | .join_time // empty')
              fi
            fi
            
            if [ -n "$LOCK_ISSUE_JOIN_TIME" ]; then
              # 计算锁持有时间
              JOIN_TIMESTAMP=$(date -d "$LOCK_ISSUE_JOIN_TIME" +%s 2>/dev/null || echo "0")
              CURRENT_TIMESTAMP=$(date +%s)
              LOCK_DURATION=$((CURRENT_TIMESTAMP - JOIN_TIMESTAMP))
              LOCK_DURATION_HOURS=$((LOCK_DURATION / 3600))
              
              echo "Lock duration: ${LOCK_DURATION_HOURS} hours"
              
              if [ "$LOCK_DURATION_HOURS" -ge 2 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASON="${CLEANUP_REASON}• 锁超时：已占用${LOCK_DURATION_HOURS}小时
          "
                echo "❌ Lock timeout detected: ${LOCK_DURATION_HOURS} hours"
              fi
            fi
          fi
          
          # 3. 检查队列中是否有重复项
          if [ "$(echo "$ISSUE_QUEUE" | jq -r 'type')" = "array" ]; then
            DUPLICATE_ISSUES=$(echo "$ISSUE_QUEUE" | \
              jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number' 2>/dev/null || echo "")
            
            if [ -n "$DUPLICATE_ISSUES" ]; then
              NEED_CLEANUP=true
              CLEANUP_REASON="${CLEANUP_REASON}• 队列重复：Issue $DUPLICATE_ISSUES 重复
          "
              echo "❌ Duplicate issues detected: $DUPLICATE_ISSUES"
            fi
          fi
          
          if [ "$(echo "$WORKFLOW_QUEUE" | jq -r 'type')" = "array" ]; then
            DUPLICATE_WORKFLOWS=$(echo "$WORKFLOW_QUEUE" | \
              jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number' 2>/dev/null || echo "")
            
            if [ -n "$DUPLICATE_WORKFLOWS" ]; then
              NEED_CLEANUP=true
              CLEANUP_REASON="${CLEANUP_REASON}• 队列重复：Workflow $DUPLICATE_WORKFLOWS 重复
          "
              echo "❌ Duplicate workflows detected: $DUPLICATE_WORKFLOWS"
            fi
          fi
          
          # 4. 检查队列中是否有已完成的构建
          if [ "$CURRENT_BUILD" != "null" ] && [ "$CURRENT_BUILD" != "null" ]; then
            # 检查当前构建是否还在队列中
            ISSUE_IN_QUEUE=$(echo "$ISSUE_QUEUE" | \
              jq -r --arg issue_number "$CURRENT_BUILD" \
              'map(.issue_number) | contains([$issue_number])' 2>/dev/null || echo "false")
            
            WORKFLOW_IN_QUEUE=$(echo "$WORKFLOW_QUEUE" | \
              jq -r --arg issue_number "$CURRENT_BUILD" \
              'map(.issue_number) | contains([$issue_number])' 2>/dev/null || echo "false")
            
            if [ "$ISSUE_IN_QUEUE" != "true" ] && [ "$WORKFLOW_IN_QUEUE" != "true" ]; then
              NEED_CLEANUP=true
              CLEANUP_REASON="${CLEANUP_REASON}• 构建完成：Issue $CURRENT_BUILD 已不在队列中
          "
              echo "❌ Build completed but lock not released: $CURRENT_BUILD"
            fi
          fi
          
          # 执行清理
          if [ "$NEED_CLEANUP" = true ]; then
            echo "Performing queue cleanup..."
            echo "Cleanup reasons: $CLEANUP_REASON"
            
            # 清理后的队列数据
            CLEANED_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq '
              # 移除重复项
              .issue_queue = (.issue_queue | group_by(.issue_number) | map(.[0]))
              | .workflow_queue = (.workflow_queue | group_by(.issue_number) | map(.[0]))
              # 重置异常锁
              | .current_build = null
              | .lock_holder = null
            ')
            
            # 计算清理后的队列数量
            CLEANED_ISSUE_COUNT=$(echo "$CLEANED_QUEUE_DATA" | jq '.issue_queue | length')
            CLEANED_WORKFLOW_COUNT=$(echo "$CLEANED_QUEUE_DATA" | jq '.workflow_queue | length')
            CLEANED_TOTAL_COUNT=$((CLEANED_ISSUE_COUNT + CLEANED_WORKFLOW_COUNT))
            
            # 更新队列管理issue
            CLEANED_BODY="## 构建队列管理

          **最后更新时间：** $(date '+%Y-%m-%d %H:%M:%S')

          ### 当前状态
          - **构建锁状态：** 空闲 🔓 (已清理)
          - **当前构建：** 无
          - **锁持有者：** 无

          ### Issue队列 (最多3个)
          - 当前数量：$CLEANED_ISSUE_COUNT/3

          ### Workflow队列 (最多5个)
          - 当前数量：$CLEANED_WORKFLOW_COUNT/5

          ### 总队列 (最多5个)
          - 当前数量：$CLEANED_TOTAL_COUNT/5

          ---

          ### 清理记录
          **清理时间：** $(date '+%Y-%m-%d %H:%M:%S')
          **清理原因：**
          $CLEANUP_REASON

          ### 队列数据
          \`\`\`json
          $CLEANED_QUEUE_DATA
          \`\`\`"
            
            # 更新队列管理issue
            curl -X PATCH \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Content-Type: application/json" \
              "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE" \
              -d "$(jq -n --arg body "$CLEANED_BODY" '{"body": $body}')"
            
            echo "Queue cleanup completed successfully!"
            echo "Cleaned issue count: $CLEANED_ISSUE_COUNT"
            echo "Cleaned workflow count: $CLEANED_WORKFLOW_COUNT"
            echo "Cleaned total count: $CLEANED_TOTAL_COUNT"
            
            # 保存清理后的数据供后续使用
            echo "CLEANED_QUEUE_DATA=$CLEANED_QUEUE_DATA" >> $GITHUB_ENV
            echo "QUEUE_CLEANED=true" >> $GITHUB_ENV
          else
            echo "No cleanup needed, queue is healthy"
            echo "QUEUE_CLEANED=false" >> $GITHUB_ENV
          fi

      - name: Check queue status
        id: check_queue
        run: |
          # 获取当前队列状态
          echo "Checking current queue status..."
          
          # 队列管理issue编号
          QUEUE_MANAGER_ISSUE="1"
          
          # 检查是否已经清理过队列
          if [ "${{ env.QUEUE_CLEANED }}" = "true" ]; then
            echo "Using cleaned queue data from previous step"
            QUEUE_DATA='${{ env.CLEANED_QUEUE_DATA }}'
          else
            # 获取队列管理issue的内容
            QUEUE_MANAGER_CONTENT=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
            
            # 检查issue是否存在
            if echo "$QUEUE_MANAGER_CONTENT" | jq -e '.message' | grep -q "Not Found"; then
              echo "Error: Queue manager issue #$QUEUE_MANAGER_ISSUE not found"
              exit 1
            fi
            
            # 解析队列数据（从issue body中提取JSON）
            QUEUE_DATA=$(echo "$QUEUE_MANAGER_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
            
            if [ -z "$QUEUE_DATA" ]; then
              # 如果队列数据不存在，初始化空队列
              echo "Initializing empty queue..."
              QUEUE_DATA='{"issue_queue":[],"workflow_queue":[],"current_build":null,"lock_holder":null}'
              
              # 创建初始队列管理内容
              INITIAL_BODY="## 构建队列管理

            **最后更新时间：** $(date '+%Y-%m-%d %H:%M:%S')

            ### 当前状态
            - **构建锁状态：** 空闲 🔓
            - **当前构建：** 无
            - **锁持有者：** 无

            ### Issue队列 (最多3个)
            - 当前数量：0/3

            ### Workflow队列 (最多5个)
            - 当前数量：0/5

            ### 总队列 (最多5个)
            - 当前数量：0/5

            ---

            ### 队列数据
            \`\`\`json
            $QUEUE_DATA
            \`\`\`"
              
              # 更新队列管理issue
              curl -X PATCH \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE" \
                -d "$(jq -n --arg body "$INITIAL_BODY" '{"body": $body}')"
            fi
          fi
          
          # 验证JSON格式
          echo "Validating JSON format..."
          echo "$QUEUE_DATA" | jq . > /dev/null
          echo "JSON validation passed"
          
          # 调试输出队列数据
          echo "Queue data: $QUEUE_DATA"
          echo "Queue data type: $(echo "$QUEUE_DATA" | jq -r 'type')"
          echo "Issue queue: $(echo "$QUEUE_DATA" | jq -r '.issue_queue')"
          echo "Workflow queue: $(echo "$QUEUE_DATA" | jq -r '.workflow_queue')"
          echo "Current build: $(echo "$QUEUE_DATA" | jq -r '.current_build')"
          echo "Lock holder: $(echo "$QUEUE_DATA" | jq -r '.lock_holder')"
          
          # 获取当前各类型队列数量
          ISSUE_QUEUE_COUNT=$(echo "$QUEUE_DATA" | jq '.issue_queue | length')
          WORKFLOW_QUEUE_COUNT=$(echo "$QUEUE_DATA" | jq '.workflow_queue | length')
          TOTAL_QUEUE_COUNT=$((ISSUE_QUEUE_COUNT + WORKFLOW_QUEUE_COUNT))
          CURRENT_BUILD=$(echo "$QUEUE_DATA" | jq -r '.current_build')
          LOCK_HOLDER=$(echo "$QUEUE_DATA" | jq -r '.lock_holder')
          
          echo "Current issue queue count: $ISSUE_QUEUE_COUNT/3"
          echo "Current workflow queue count: $WORKFLOW_QUEUE_COUNT/5"
          echo "Total queue count: $TOTAL_QUEUE_COUNT/5"
          echo "Current build: $CURRENT_BUILD"
          echo "Lock holder: $LOCK_HOLDER"
          
          # 检查是否可以加入队列
          QUEUE_FULL=false
          REJECT_REASON=""
          
          # 检查总队列限制
          if [ "$TOTAL_QUEUE_COUNT" -ge 5 ]; then
            QUEUE_FULL=true
            REJECT_REASON="总队列已满 (当前: $TOTAL_QUEUE_COUNT/5)"
          elif [ "$TRIGGER_TYPE" = "issue" ] && [ "$ISSUE_QUEUE_COUNT" -ge 3 ]; then
            QUEUE_FULL=true
            REJECT_REASON="Issue队列已满 (当前: $ISSUE_QUEUE_COUNT/3)"
          elif [ "$TRIGGER_TYPE" = "workflow_dispatch" ] && [ "$WORKFLOW_QUEUE_COUNT" -ge 5 ]; then
            QUEUE_FULL=true
            REJECT_REASON="Workflow队列已满 (当前: $WORKFLOW_QUEUE_COUNT/5)"
          else
            QUEUE_FULL=false
          fi
          
          if [ "$QUEUE_FULL" = true ]; then
            echo "Queue is full: $REJECT_REASON"
            echo "QUEUE_FULL=true" >> $GITHUB_ENV
            echo "REJECT_REASON=$REJECT_REASON" >> $GITHUB_ENV
            
            # 计算预计等待时间（假设每个构建需要30分钟）
            ESTIMATED_WAIT=$((TOTAL_QUEUE_COUNT * 30))
            echo "ESTIMATED_WAIT=$ESTIMATED_WAIT" >> $GITHUB_ENV
          else
            echo "Queue has space"
            echo "QUEUE_FULL=false" >> $GITHUB_ENV
          fi
          
          # 保存队列数据供后续使用
          echo "QUEUE_DATA=$QUEUE_DATA" >> $GITHUB_ENV
          echo "CURRENT_BUILD=$CURRENT_BUILD" >> $GITHUB_ENV
          echo "LOCK_HOLDER=$LOCK_HOLDER" >> $GITHUB_ENV

      - name: Handle queue full
        if: env.QUEUE_FULL == 'true'
        run: |
          # 从环境变量获取队列数据
          QUEUE_DATA='${{ env.QUEUE_DATA }}'
          ISSUE_QUEUE_COUNT=$(echo "$QUEUE_DATA" | jq '.issue_queue | length')
          WORKFLOW_QUEUE_COUNT=$(echo "$QUEUE_DATA" | jq '.workflow_queue | length')
          TOTAL_QUEUE_COUNT=$((ISSUE_QUEUE_COUNT + WORKFLOW_QUEUE_COUNT))
          REJECT_REASON='${{ env.REJECT_REASON }}'
          ESTIMATED_WAIT='${{ env.ESTIMATED_WAIT }}'
          
          # 队列满员，拒绝请求
          REJECT_COMMENT="## ❌ 队列已满

          **拒绝原因：** $REJECT_REASON
          **当前队列状态：**
          - Issue队列：$ISSUE_QUEUE_COUNT/3
          - Workflow队列：$WORKFLOW_QUEUE_COUNT/5
          - 总队列：$TOTAL_QUEUE_COUNT/5
          **预计等待时间：** 约${ESTIMATED_WAIT}分钟

          **建议：**
          - 请稍后重试
          - 或使用其他触发方式

          **时间：** $(date '+%Y-%m-%d %H:%M:%S')"
          
          # 添加拒绝评论
          echo -e "$REJECT_COMMENT" | jq -Rs '{body: .}' | \
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d @-
          
          # 退出工作流
          exit 1

      - name: Join queue
        if: env.QUEUE_FULL == 'false'
        run: |
          # 加入队列
          echo "Joining queue..."
          
          # 从环境变量获取队列数据
          QUEUE_DATA='${{ env.QUEUE_DATA }}'
          CURRENT_BUILD='${{ env.CURRENT_BUILD }}'
          LOCK_HOLDER='${{ env.LOCK_HOLDER }}'
          
          echo "Retrieved queue data: $QUEUE_DATA"
          echo "Current build: $CURRENT_BUILD"
          echo "Lock holder: $LOCK_HOLDER"
          
          # 简单验证队列数据
          echo "Validating queue data..."
          echo "Queue data type: $(echo "$QUEUE_DATA" | jq -r 'type')"
          
          # 检查是否是对象
          if [ "$(echo "$QUEUE_DATA" | jq -r 'type')" != "object" ]; then
            echo "❌ QUEUE_DATA is not an object"
            exit 1
          fi
          
          echo "✅ QUEUE_DATA is an object"
          
          # 获取当前issue信息
          CURRENT_ISSUE_NUMBER="${{ github.event.issue.number }}"
          CURRENT_ISSUE_TITLE="${{ github.event.issue.title }}"
          CURRENT_USER="${{ github.actor }}"
          JOIN_TIME=$(date -Iseconds)
          
          # 创建队列项
          QUEUE_ITEM=$(jq -n \
            --arg issue_number "$CURRENT_ISSUE_NUMBER" \
            --arg issue_title "$CURRENT_ISSUE_TITLE" \
            --arg user "$CURRENT_USER" \
            --arg join_time "$JOIN_TIME" \
            '{
              issue_number: $issue_number,
              issue_title: $issue_title,
              user: $user,
              join_time: $join_time
            }')
          
          echo "Queue item: $QUEUE_ITEM"
          
          # 更新队列数据
          if [ "$TRIGGER_TYPE" = "issue" ]; then
            UPDATED_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --argjson item "$QUEUE_ITEM" '.issue_queue += [$item]')
            echo "Updated issue queue"
          else
            UPDATED_QUEUE_DATA=$(echo "$QUEUE_DATA" | jq --argjson item "$QUEUE_ITEM" '.workflow_queue += [$item]')
            echo "Updated workflow queue"
          fi
          
          echo "Updated queue data: $UPDATED_QUEUE_DATA"
          
          # 计算队列数量
          UPDATED_ISSUE_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.issue_queue | length')
          UPDATED_WORKFLOW_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.workflow_queue | length')
          UPDATED_TOTAL_COUNT=$((UPDATED_ISSUE_COUNT + UPDATED_WORKFLOW_COUNT))
          
          echo "Updated counts - Issue: $UPDATED_ISSUE_COUNT, Workflow: $UPDATED_WORKFLOW_COUNT, Total: $UPDATED_TOTAL_COUNT"
          
          # 更新队列管理issue
          QUEUE_MANAGER_ISSUE="1"
          
          echo "Preparing to update queue manager issue..."
          echo "UPDATED_QUEUE_DATA type: $(echo "$UPDATED_QUEUE_DATA" | jq -r 'type')"
          echo "UPDATED_QUEUE_DATA keys: $(echo "$UPDATED_QUEUE_DATA" | jq -r 'keys | join(",")')"
          
          # 确定锁状态显示
          if [ "$CURRENT_BUILD" = "null" ] || [ "$CURRENT_BUILD" = "null" ]; then
            LOCK_STATUS="空闲 🔓"
            CURRENT_BUILD_DISPLAY="无"
            LOCK_HOLDER_DISPLAY="无"
          else
            LOCK_STATUS="占用 🔒"
            CURRENT_BUILD_DISPLAY="$CURRENT_BUILD"
            LOCK_HOLDER_DISPLAY="$LOCK_HOLDER"
          fi
          
          UPDATED_BODY="## 构建队列管理

          **最后更新时间：** $(date '+%Y-%m-%d %H:%M:%S')

          ### 当前状态
          - **构建锁状态：** $LOCK_STATUS
          - **当前构建：** $CURRENT_BUILD_DISPLAY
          - **锁持有者：** $LOCK_HOLDER_DISPLAY

          ### Issue队列 (最多3个)
          - 当前数量：$UPDATED_ISSUE_COUNT/3

          ### Workflow队列 (最多5个)
          - 当前数量：$UPDATED_WORKFLOW_COUNT/5

          ### 总队列 (最多5个)
          - 当前数量：$UPDATED_TOTAL_COUNT/5

          ---

          ### 队列数据
          \`\`\`json
          $UPDATED_QUEUE_DATA
          \`\`\`"
          
          echo "Generated UPDATED_BODY, length: ${#UPDATED_BODY}"
          echo "About to update issue #$QUEUE_MANAGER_ISSUE..."
          
          # 更新队列管理issue
          curl -X PATCH \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE" \
            -d "$(jq -n --arg body "$UPDATED_BODY" '{"body": $body}')"
          
          echo "Issue update completed successfully"
          
          # 计算队列位置
          if [ "$TRIGGER_TYPE" = "issue" ]; then
            QUEUE_POSITION=$UPDATED_ISSUE_COUNT
            QUEUE_LIMIT=3
          else
            QUEUE_POSITION=$UPDATED_WORKFLOW_COUNT
            QUEUE_LIMIT=5
          fi
          echo "QUEUE_POSITION=$QUEUE_POSITION" >> $GITHUB_ENV
          
          echo "Preparing queue join comment..."
          echo "Using UPDATED_TOTAL_COUNT: $UPDATED_TOTAL_COUNT"
          echo "Calculated QUEUE_POSITION: $QUEUE_POSITION"
          
          # 添加队列加入评论
          QUEUE_JOIN_COMMENT="## 已加入队列

          **队列位置：** $QUEUE_POSITION/$QUEUE_LIMIT ($TRIGGER_TYPE队列)
          **预计等待时间：** 约$((UPDATED_TOTAL_COUNT * 30))分钟
          **状态：** 等待中 ⏳

          **当前队列状态：**
          - Issue队列：$UPDATED_ISSUE_COUNT/3
          - Workflow队列：$UPDATED_WORKFLOW_COUNT/5
          - 总队列：$UPDATED_TOTAL_COUNT/5

          **构建锁状态：** $LOCK_STATUS

          **队列信息：**
          - 加入时间：$(date '+%Y-%m-%d %H:%M:%S')
          - 触发方式：$TRIGGER_TYPE
          - 队列管理：Issue #$QUEUE_MANAGER_ISSUE"
          
          echo "Generated QUEUE_JOIN_COMMENT, length: ${#QUEUE_JOIN_COMMENT}"
          echo "About to post comment..."
          
          echo -e "$QUEUE_JOIN_COMMENT" | jq -Rs '{body: .}' | \
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d @-
          
          echo "Comment posted successfully"
          
          # 验证队列更新是否成功
          echo "Verifying queue update..."
          sleep 5  # 等待API更新
          
          VERIFY_CONTENT=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
          
          VERIFY_QUEUE_DATA=$(echo "$VERIFY_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
          echo "Verified queue data: $VERIFY_QUEUE_DATA"
          
          VERIFY_ISSUE_COUNT=$(echo "$VERIFY_QUEUE_DATA" | jq '.issue_queue | length')
          VERIFY_WORKFLOW_COUNT=$(echo "$VERIFY_QUEUE_DATA" | jq '.workflow_queue | length')
          echo "Verified counts - Issue: $VERIFY_ISSUE_COUNT, Workflow: $VERIFY_WORKFLOW_COUNT"
          
          # 检查当前issue是否在队列中
          ISSUE_IN_VERIFIED_QUEUE=$(echo "$VERIFY_QUEUE_DATA" | \
            jq -r --arg issue_number "$CURRENT_ISSUE_NUMBER" \
            '.issue_queue | map(.issue_number) | contains([$issue_number])')
          echo "Issue in verified queue: $ISSUE_IN_VERIFIED_QUEUE"

      - name: Wait in queue
        if: env.QUEUE_FULL == 'false'
        run: |
          # 等待轮到自己的位置并获取构建锁
          echo "Waiting in queue and for build lock..."
          
          START_TIME=$(date +%s)
          TIMEOUT=7200  # 2小时超时
          
          while [ $(($(date +%s) - START_TIME)) -lt $TIMEOUT ]; do
            echo "Checking queue position and lock status... ($(($(date +%s) - START_TIME))s elapsed)"
            
            # 重新获取队列管理issue的内容
            QUEUE_MANAGER_ISSUE="1"
            QUEUE_MANAGER_CONTENT=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
            
            # 解析队列数据
            CURRENT_QUEUE_DATA=$(echo "$QUEUE_MANAGER_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
            
            # 调试输出
            echo "Current queue data: $CURRENT_QUEUE_DATA"
            echo "Current issue number: ${{ github.event.issue.number }}"
            echo "Trigger type: $TRIGGER_TYPE"
            
            # 获取当前队列状态
            CURRENT_ISSUE_COUNT=$(echo "$CURRENT_QUEUE_DATA" | jq '.issue_queue | length')
            CURRENT_WORKFLOW_COUNT=$(echo "$CURRENT_QUEUE_DATA" | jq '.workflow_queue | length')
            CURRENT_TOTAL_COUNT=$((CURRENT_ISSUE_COUNT + CURRENT_WORKFLOW_COUNT))
            CURRENT_BUILD=$(echo "$CURRENT_QUEUE_DATA" | jq -r '.current_build')
            LOCK_HOLDER=$(echo "$CURRENT_QUEUE_DATA" | jq -r '.lock_holder')
            
            echo "Current counts - Issue: $CURRENT_ISSUE_COUNT, Workflow: $CURRENT_WORKFLOW_COUNT, Total: $CURRENT_TOTAL_COUNT"
            echo "Current build: $CURRENT_BUILD"
            echo "Lock holder: $LOCK_HOLDER"
            
            # 检查当前issue是否在队列中
            if [ "$TRIGGER_TYPE" = "issue" ]; then
              ISSUE_IN_QUEUE=$(echo "$CURRENT_QUEUE_DATA" | \
                jq -r --arg issue_number "${{ github.event.issue.number }}" \
                '.issue_queue | map(.issue_number) | contains([$issue_number])')
              CURRENT_POSITION=$(echo "$CURRENT_QUEUE_DATA" | \
                jq -r --arg issue_number "${{ github.event.issue.number }}" \
                '.issue_queue | map(.issue_number) | index($issue_number) // empty | . + 1')
              QUEUE_LIMIT=3
            else
              ISSUE_IN_QUEUE=$(echo "$CURRENT_QUEUE_DATA" | \
                jq -r --arg issue_number "${{ github.event.issue.number }}" \
                '.workflow_queue | map(.issue_number) | contains([$issue_number])')
              CURRENT_POSITION=$(echo "$CURRENT_QUEUE_DATA" | \
                jq -r --arg issue_number "${{ github.event.issue.number }}" \
                '.workflow_queue | map(.issue_number) | index($issue_number) // empty | . + 1')
              QUEUE_LIMIT=5
            fi
            
            echo "Issue in queue: $ISSUE_IN_QUEUE"
            echo "Calculated position: '$CURRENT_POSITION'"
            
            # 如果issue不在队列中，直接进入构建
            if [ "$ISSUE_IN_QUEUE" != "true" ]; then
              echo "Issue not found in queue, proceeding to build..."
              break
            fi
            
            # 检查是否是首位
            if [ "$CURRENT_POSITION" != "1" ]; then
              echo "Not at front of queue (position: $CURRENT_POSITION), waiting..."
              
              # 更新队列状态评论
              UPDATE_COMMENT="## 队列状态更新

              **当前位置：** $CURRENT_POSITION/$QUEUE_LIMIT ($TRIGGER_TYPE队列)
              **预计等待时间：** 约$((CURRENT_TOTAL_COUNT * 30))分钟
              **状态：** 等待队列位置 ⏳

              **当前队列状态：**
              - Issue队列：$CURRENT_ISSUE_COUNT/3
              - Workflow队列：$CURRENT_WORKFLOW_COUNT/5
              - 总队列：$CURRENT_TOTAL_COUNT/5

              **构建锁状态：** $([ "$CURRENT_BUILD" = "null" ] && echo "空闲 🔓" || echo "占用 🔒")

              **更新时间：** $(date '+%Y-%m-%d %H:%M:%S')"
              
              # 添加新评论
              echo -e "$UPDATE_COMMENT" | jq -Rs '{body: .}' | \
                curl -X POST \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
                  -d @-
              
              # 等待5分钟后再次检查
              sleep 300
              continue
            fi
            
            # 检查构建锁是否可用
            if [ "$CURRENT_BUILD" != "null" ] && [ "$CURRENT_BUILD" != "null" ]; then
              echo "Build lock is held by: $LOCK_HOLDER (build: $CURRENT_BUILD), waiting for lock..."
              
              # 更新等待锁状态评论
              LOCK_WAIT_COMMENT="## 等待构建锁

              **队列位置：** 1/$QUEUE_LIMIT ($TRIGGER_TYPE队列) ✅
              **构建锁状态：** 占用 🔒
              **当前构建：** $CURRENT_BUILD
              **锁持有者：** $LOCK_HOLDER
              **状态：** 等待构建锁释放 ⏳

              **当前队列状态：**
              - Issue队列：$CURRENT_ISSUE_COUNT/3
              - Workflow队列：$CURRENT_WORKFLOW_COUNT/5
              - 总队列：$CURRENT_TOTAL_COUNT/5

              **更新时间：** $(date '+%Y-%m-%d %H:%M:%S')"
              
              # 添加新评论
              echo -e "$LOCK_WAIT_COMMENT" | jq -Rs '{body: .}' | \
                curl -X POST \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
                  -d @-
              
              # 等待5分钟后再次检查
              sleep 300
              continue
            fi
            
            # 如果到达首位且锁可用，尝试获取锁
            echo "At front of queue and lock is available, attempting to acquire lock..."
            
            # 尝试获取构建锁
            LOCK_ACQUIRED=false
            
            # 重新获取最新队列数据
            LATEST_CONTENT=$(curl -s \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
            
            LATEST_QUEUE_DATA=$(echo "$LATEST_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
            LATEST_BUILD=$(echo "$LATEST_QUEUE_DATA" | jq -r '.current_build')
            
            # 再次检查锁是否仍然可用
            if [ "$LATEST_BUILD" = "null" ] || [ "$LATEST_BUILD" = "null" ]; then
              # 获取锁
              UPDATED_QUEUE_DATA=$(echo "$LATEST_QUEUE_DATA" | \
                jq --arg issue_number "${{ github.event.issue.number }}" \
                --arg user "${{ github.actor }}" \
                '.current_build = $issue_number | .lock_holder = $user')
              
              # 更新队列管理issue
              UPDATED_BODY="## 构建队列管理

              **最后更新时间：** $(date '+%Y-%m-%d %H:%M:%S')

              ### 当前状态
              - **构建锁状态：** 占用 🔒
              - **当前构建：** ${{ github.event.issue.number }}
              - **锁持有者：** ${{ github.actor }}

              ### Issue队列 (最多3个)
              - 当前数量：$CURRENT_ISSUE_COUNT/3

              ### Workflow队列 (最多5个)
              - 当前数量：$CURRENT_WORKFLOW_COUNT/5

              ### 总队列 (最多5个)
              - 当前数量：$CURRENT_TOTAL_COUNT/5

              ---

              ### 队列数据
              \`\`\`json
              $UPDATED_QUEUE_DATA
              \`\`\`"
              
              # 更新队列管理issue
              curl -X PATCH \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                -H "Content-Type: application/json" \
                "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE" \
                -d "$(jq -n --arg body "$UPDATED_BODY" '{"body": $body}')"
              
              LOCK_ACQUIRED=true
              echo "Build lock acquired successfully!"
            else
              echo "Lock was taken by another process, continuing to wait..."
              sleep 30
              continue
            fi
            
            if [ "$LOCK_ACQUIRED" = true ]; then
              echo "Lock acquired, proceeding to build!"
              break
            fi
          done
          
          if [ $(($(date +%s) - START_TIME)) -ge $TIMEOUT ]; then
            echo "Queue timeout after 2 hours"
            # 添加超时评论
            TIMEOUT_COMMENT="## ⏰ 队列等待超时

            **状态：** 队列等待超时（2小时）
            **时间：** $(date '+%Y-%m-%d %H:%M:%S')
            构建将自动终止。如需重新构建，请重新提交issue。"
            
            echo -e "$TIMEOUT_COMMENT" | jq -Rs '{body: .}' | \
              curl -X POST \
                -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                -H "Accept: application/vnd.github.v3+json" \
                https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
                -d @-
            
            exit 1
          fi

      - name: Leave queue
        if: env.QUEUE_FULL == 'false'
        run: |
          # 离开队列，开始构建
          echo "Leaving queue to start build..."
          
          # 从队列管理issue中移除当前issue
          QUEUE_MANAGER_ISSUE="1"
          QUEUE_MANAGER_CONTENT=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
          
          # 解析当前队列数据
          CURRENT_QUEUE_DATA=$(echo "$QUEUE_MANAGER_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
          
          # 从对应队列中移除当前issue
          if [ "$TRIGGER_TYPE" = "issue" ]; then
            UPDATED_QUEUE_DATA=$(echo "$CURRENT_QUEUE_DATA" | \
              jq --arg issue_number "${{ github.event.issue.number }}" \
              '.issue_queue = (.issue_queue | map(select(.issue_number != $issue_number)))')
          else
            UPDATED_QUEUE_DATA=$(echo "$CURRENT_QUEUE_DATA" | \
              jq --arg issue_number "${{ github.event.issue.number }}" \
              '.workflow_queue = (.workflow_queue | map(select(.issue_number != $issue_number)))')
          fi
          
          # 计算更新后的队列数量
          UPDATED_ISSUE_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.issue_queue | length')
          UPDATED_WORKFLOW_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.workflow_queue | length')
          UPDATED_TOTAL_COUNT=$((UPDATED_ISSUE_COUNT + UPDATED_WORKFLOW_COUNT))
          
          echo "Updated counts after leaving - Issue: $UPDATED_ISSUE_COUNT, Workflow: $UPDATED_WORKFLOW_COUNT, Total: $UPDATED_TOTAL_COUNT"
          
          # 更新队列管理issue
          UPDATED_BODY="## 构建队列管理

          **最后更新时间：** $(date '+%Y-%m-%d %H:%M:%S')

          ### 当前状态
          - **构建锁状态：** 占用 🔒
          - **当前构建：** ${{ github.event.issue.number }}
          - **锁持有者：** ${{ github.actor }}

          ### Issue队列 (最多3个)
          - 当前数量：$UPDATED_ISSUE_COUNT/3

          ### Workflow队列 (最多5个)
          - 当前数量：$UPDATED_WORKFLOW_COUNT/5

          ### 总队列 (最多5个)
          - 当前数量：$UPDATED_TOTAL_COUNT/5

          ---

          ### 队列数据
          \`\`\`json
          $UPDATED_QUEUE_DATA
          \`\`\`"
          
          # 更新队列管理issue
          curl -X PATCH \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE" \
            -d "$(jq -n --arg body "$UPDATED_BODY" '{"body": $body}')"
          
          # 添加开始构建评论
          BUILD_START_COMMENT="## 🚀 开始构建

          **状态：** 构建已开始
          **构建锁：** 已获取 🔒
          **时间：** $(date '+%Y-%m-%d %H:%M:%S')
          构建过程正在进行中..."

          echo -e "$BUILD_START_COMMENT" | jq -Rs '{body: .}' | \
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d @-

      - name: Process data
        if: env.QUEUE_FULL == 'false'
        id: process
        run: |
          # 处理数据（添加队列信息）
          CURRENT_DATA='${{ env.CURRENT_DATA }}'
          
          # 验证JSON格式
          echo "Validating input JSON..."
          echo "$CURRENT_DATA" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # 使用jq处理JSON，添加队列信息
          PROCESSED=$(echo "$CURRENT_DATA" | jq -c \
            --arg queue_time "$(date -Iseconds)" \
            --arg queue_position "$QUEUE_POSITION" \
            --arg trigger_type "$TRIGGER_TYPE" \
            '. + {queued: true, queue_time: $queue_time, queue_position: $queue_position, trigger_type: $trigger_type}')
          
          # 验证处理后的JSON格式
          echo "Validating processed JSON..."
          echo "$PROCESSED" | jq . > /dev/null
          echo "Processed JSON validation passed"
          
          echo "CURRENT_DATA=$PROCESSED" >> $GITHUB_ENV

      - name: Output data
        if: env.QUEUE_FULL == 'false'
        id: output
        run: |
          # 输出处理后的数据
          OUTPUT_DATA='${{ env.CURRENT_DATA }}'
          
          # 验证输出JSON格式
          echo "Validating output JSON format..."
          echo "$OUTPUT_DATA" | jq . > /dev/null
          echo "Output JSON validation passed"
          
          echo "data=$OUTPUT_DATA" >> $GITHUB_OUTPUT
          
          # 显示输出信息
          echo "Queue output: $OUTPUT_DATA"

  build: # 构建阶段
    needs: queue
    runs-on: ubuntu-latest
    if: needs.queue.outputs.queue_output != null
    outputs:
      build_output: ${{ toJson(steps.output.outputs.data) }}
    steps:
      - name: Extract data
        id: extract
        run: |
          # 仅提取数据，不进行任何处理
          INPUT='${{ fromJson(needs.queue.outputs.queue_output) }}'
          
          # 验证输入JSON格式
          echo "Validating input JSON format..."
          echo "$INPUT" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # 设置环境变量供后续步骤使用
          echo "CURRENT_DATA=$INPUT" >> $GITHUB_ENV

      - name: Pause for 5 minutes (for queue test)
        run: |
          echo "Pausing for 5 minutes to test queue..."
          sleep 300

      - name: Process data
        id: process
        run: |
          # 处理数据（添加构建状态）
          # 从环境变量中安全地提取JSON数据
          CURRENT_DATA='${{ env.CURRENT_DATA }}'
          
          # 验证JSON格式
          echo "Validating input JSON..."
          echo "$CURRENT_DATA" | jq . > /dev/null
          echo "Input JSON validation passed"
          
          # 使用jq处理JSON，添加构建状态
          PROCESSED=$(echo "$CURRENT_DATA" | jq -c --arg build_time "$(date -Iseconds)" '. + {built: true, build_time: $build_time}')
          
          # 验证处理后的JSON格式
          echo "Validating processed JSON..."
          echo "$PROCESSED" | jq . > /dev/null
          echo "Processed JSON validation passed"
          
          echo "CURRENT_DATA=$PROCESSED" >> $GITHUB_ENV

      - name: Output data
        id: output
        run: |
          # 直接使用Process步骤处理后的数据
          OUTPUT_DATA='${{ env.CURRENT_DATA }}'
          
          # 验证输出JSON格式
          echo "Validating output JSON format..."
          echo "$OUTPUT_DATA" | jq . > /dev/null
          echo "Output JSON validation passed"
          
          echo "data=$OUTPUT_DATA" >> $GITHUB_OUTPUT
          
          # 显示输出信息
          echo "Build output: $OUTPUT_DATA"

  finish: # 收尾阶段
    needs: build
    runs-on: ubuntu-latest
    if: needs.build.outputs.build_output != null
    steps:
      - name: Parse input
        run: |
          # 正确获取输入数据
          INPUT='${{ fromJson(needs.build.outputs.build_output) }}'
          echo "FINAL_INPUT=$INPUT" >> $GITHUB_ENV

      - name: Release build lock
        run: |
          # 释放构建锁
          echo "Releasing build lock..."
          
          QUEUE_MANAGER_ISSUE="1"
          QUEUE_MANAGER_CONTENT=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE")
          
          # 解析当前队列数据
          CURRENT_QUEUE_DATA=$(echo "$QUEUE_MANAGER_CONTENT" | jq -r '.body' | grep -oP '```json\K.*?(?=```)' | head -1)
          
          # 释放锁
          UPDATED_QUEUE_DATA=$(echo "$CURRENT_QUEUE_DATA" | \
            jq '.current_build = null | .lock_holder = null')
          
          # 计算队列数量
          UPDATED_ISSUE_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.issue_queue | length')
          UPDATED_WORKFLOW_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.workflow_queue | length')
          UPDATED_TOTAL_COUNT=$((UPDATED_ISSUE_COUNT + UPDATED_WORKFLOW_COUNT))
          
          # 更新队列管理issue
          UPDATED_BODY="## 构建队列管理

          **最后更新时间：** $(date '+%Y-%m-%d %H:%M:%S')

          ### 当前状态
          - **构建锁状态：** 空闲 🔓
          - **当前构建：** 无
          - **锁持有者：** 无

          ### Issue队列 (最多3个)
          - 当前数量：$UPDATED_ISSUE_COUNT/3

          ### Workflow队列 (最多5个)
          - 当前数量：$UPDATED_WORKFLOW_COUNT/5

          ### 总队列 (最多5个)
          - 当前数量：$UPDATED_TOTAL_COUNT/5

          ---

          ### 队列数据
          \`\`\`json
          $UPDATED_QUEUE_DATA
          \`\`\`"
          
          # 更新队列管理issue
          curl -X PATCH \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/issues/$QUEUE_MANAGER_ISSUE" \
            -d "$(jq -n --arg body "$UPDATED_BODY" '{"body": $body}')"
          
          echo "Build lock released successfully!"

      - name: Final processing
        run: |
          # 使用jq解析单行JSON
          echo "Final data: $FINAL_INPUT"
          echo "Ready status: $(jq -r '.ready' <<< "$FINAL_INPUT")"
          echo "Version: $(jq -r '.version' <<< "$FINAL_INPUT")"

      - name: Generate report
        run: |
          echo "Build completed successfully"
          
          # 添加构建完成评论
          COMPLETION_COMMENT="## ✅ 构建完成

          **状态：** 构建已完成
          **构建锁：** 已释放 🔓
          **时间：** $(date '+%Y-%m-%d %H:%M:%S')
          下一个队列项目可以开始构建。"

          echo -e "$COMPLETION_COMMENT" | jq -Rs '{body: .}' | \
            curl -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments \
              -d @-
