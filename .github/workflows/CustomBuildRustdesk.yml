name: Custom Rustdesk Build Workflow

on:
  # Issue 触发
  issues:
    types: [opened]
  
  # 手动触发
  workflow_dispatch:
    inputs:
      tag:
        description: '构建标签'
        required: true
        default: 'custom'
      customer:
        description: '客户名称'
        required: true
        default: 'test'
      customer_link:
        description: '客户链接'
        required: false
        default: ''
      slogan:
        description: '标语'
        required: false
        default: 'Custom Rustdesk'
      email:
        description: '邮箱地址'
        required: true
        default: 'admin@example.com'
      super_password:
        description: '超级密码'
        required: true
        default: 'password123'
      rendezvous_server:
        description: 'Rendezvous服务地址'
        required: true
        default: '192.168.1.100'
      rs_pub_key:
        description: 'RS公钥'
        required: false
        default: ''
      api_server:
        description: 'API服务地址'
        required: true
        default: 'http://192.168.1.100:21114'
      enable_debug:
        description: '启用调试模式（仅手动触发时有效）'
        required: false
        default: true
        type: boolean

permissions:
  issues: write
  contents: read
  actions: read

# 统一环境变量配置
env:
  GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
  ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
  QUEUE_ISSUE_NUMBER: '1'
  DEBUG_ENABLED: ${{ vars.DEBUG_ENABLED || 'false' }}
  # 远程仓库配置 - 固定设置
  RUSTDESK_REPO: 'rustdesk/rustdesk'
  RUSTDESK_BRANCH: 'master'
  REMOTE_WORKFLOW_NAME: 'Build'
  # 默认值配置
  DEFAULT_TAG: ${{ secrets.DEFAULT_TAG }}
  DEFAULT_EMAIL: ${{ secrets.DEFAULT_EMAIL }}
  DEFAULT_CUSTOMER: ${{ secrets.DEFAULT_CUSTOMER }}
  DEFAULT_CUSTOMER_LINK: ${{ secrets.DEFAULT_CUSTOMER_LINK }}
  DEFAULT_SUPER_PASSWORD: ${{ secrets.DEFAULT_SUPER_PASSWORD }}
  DEFAULT_SLOGAN: ${{ secrets.DEFAULT_SLOGAN }}
  DEFAULT_RENDEZVOUS_SERVER: ${{ secrets.DEFAULT_RENDEZVOUS_SERVER }}
  DEFAULT_RS_PUB_KEY: ${{ secrets.DEFAULT_RS_PUB_KEY }}
  DEFAULT_API_SERVER: ${{ secrets.DEFAULT_API_SERVER }}

jobs:
  # 00-触发处理 - 提取和验证参数
  trigger:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.trigger.outputs.build_id }}
      validation_passed: ${{ steps.trigger.outputs.validation_passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Process trigger and validate parameters
        id: trigger
        run: |
          source .github/workflows/scripts/trigger.sh
          
          # 使用环境变量传递事件数据
          export EVENT_DATA='${{ toJSON(github.event) }}'
          echo "DEBUG: EVENT_DATA = $EVENT_DATA"
          echo "DEBUG: github.event_name = ${{ github.event_name }}"
          echo "DEBUG: github.event.issue.number = ${{ github.event.issue.number }}"
          
          # 添加更详细的调试信息
          echo "DEBUG: github.event 类型: object"
          echo "DEBUG: github.event 内容: Object"
          
          # 根据触发类型提取参数
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "DEBUG: 进入 workflow_dispatch 分支"
            # 提取参数并设置环境变量
            params=$(trigger_manager "extract-workflow-dispatch" "$EVENT_DATA")
            echo "DEBUG: workflow_dispatch params = $params"
            eval "$params"
            
            echo "DEBUG: After extract, TAG=$TAG, EMAIL=$EMAIL, CUSTOMER=$CUSTOMER"
            
            # 处理tag时间戳
            final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
            echo "DEBUG: final_tag = $final_tag"
            
            # 生成最终JSON数据
            final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
            echo "DEBUG: final_data = $final_data"
            echo "DEBUG: final_data 长度: ${#final_data}"
            echo "DEBUG: final_data 是否为空: $([ -z "$final_data" ] && echo "是" || echo "否")"
            
            # 验证参数
            validation_result=$(trigger_manager "validate-parameters" "$final_data")
            validation_exit_code=$?
            echo "DEBUG: validation_result = $validation_result, exit_code = $validation_exit_code"
            
            # 只输出build_id，不输出trigger_data
            build_id=$(echo "$final_data" | jq -r '.build_id // empty')
            echo "build_id=$build_id" >> $GITHUB_OUTPUT
            echo "DEBUG: build_id output completed"
          else
            echo "DEBUG: 进入 issue 分支"
            # Issue触发的情况
            params=$(trigger_manager "extract-issue" "$EVENT_DATA")
            echo "DEBUG: issue params = $params"
            eval "$params"
            
            echo "DEBUG: After extract, TAG=$TAG, EMAIL=$EMAIL, CUSTOMER=$CUSTOMER"
            
            # 处理tag时间戳
            final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
            echo "DEBUG: final_tag = $final_tag"
            
            # 生成最终JSON数据
            final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
            echo "DEBUG: final_data = $final_data"
            echo "DEBUG: final_data 长度: ${#final_data}"
            echo "DEBUG: final_data 是否为空: $([ -z "$final_data" ] && echo "是" || echo "否")"
            
            # 验证参数
            validation_result=$(trigger_manager "validate-parameters" "$final_data")
            validation_exit_code=$?
            echo "DEBUG: validation_result = $validation_result, exit_code = $validation_exit_code"
            
            # 只输出build_id，不输出trigger_data
            build_id=$(echo "$final_data" | jq -r '.build_id // empty')
            echo "build_id=$build_id" >> $GITHUB_OUTPUT
            echo "DEBUG: build_id output completed"
          fi
          
          # 设置验证结果
          if [ $validation_exit_code -eq 0 ]; then
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

  # 01-审核验证 - 处理需要审核的情况
  review:
    needs: trigger
    if: needs.trigger.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.review_passed }}
      review_reason: ${{ steps.review.outputs.review_reason }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Review and validate
        id: review
        shell: bash
        run: |
          source .github/workflows/scripts/review.sh

          # 直接使用 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'
          
          # 验证参数
          validation_result=$(review_manager "validate" "$EVENT_DATA" "" || true)
          validation_exit_code=$?
          
          if [ $validation_exit_code -ne 0 ]; then
            # 参数验证失败，处理拒绝
            review_manager "handle-rejection" "$EVENT_DATA" "" "$validation_result" || true
            echo "review_passed=false" >> $GITHUB_OUTPUT
            echo "review_reason=参数验证失败" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 检查是否需要审核
          need_review=$(review_manager "need-review" "$EVENT_DATA" "" || true)
          
          # 如果是issue触发，清理issue内容
          if [ "${{ github.event_name }}" = "issues" ]; then
            source .github/workflows/scripts/trigger.sh
            
            # 从EVENT_DATA中提取参数用于清理
            final_tag_param=$(echo "$EVENT_DATA" | jq -r '.build_params.tag // empty')
            original_tag_param=$(echo "$EVENT_DATA" | jq -r '.build_params.original_tag // empty')
            customer_param=$(echo "$EVENT_DATA" | jq -r '.build_params.customer // empty')
            slogan_param=$(echo "$EVENT_DATA" | jq -r '.build_params.slogan // empty')
            
            cleaned_body=$(trigger_manager "clean-issue" "$final_tag_param" "$original_tag_param" "$customer_param" "$slogan_param")
            issue_number="${{ github.event.issue.number }}"
            trigger_manager "update-issue" "$issue_number" "$cleaned_body"
          fi
          
          if [ "$need_review" = "true" ]; then
            # 需要审核，在issue中回复需要审核的信息
            if [ "${{ github.event_name }}" = "issues" ]; then
              source .github/workflows/scripts/issue-templates.sh
              review_comment=$(generate_review_required_template "${{ github.run_id }}" "${{ github.event.issue.number }}" "$EVENT_DATA")
              source .github/workflows/scripts/issue-manager.sh
              add_issue_comment "${{ github.event.issue.number }}" "$review_comment" || true
            fi
            
            # 处理审核流程
            review_result=$(review_manager "handle-review" "$EVENT_DATA" "" || true)
            review_exit_code=$?
            
            if [ $review_exit_code -eq 0 ]; then
              echo "review_passed=true" >> $GITHUB_OUTPUT
              echo "review_reason=" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 1 ]; then
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=审核被拒绝" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 2 ]; then
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=审核超时" >> $GITHUB_OUTPUT
            fi
          else
            # 不需要审核，直接通过
            echo "review_passed=true" >> $GITHUB_OUTPUT
            echo "review_reason=" >> $GITHUB_OUTPUT
          fi
          
          # 输出数据（传递审核结果）
          review_manager "output-data" "$EVENT_DATA" "" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 1 ] && echo "true" || echo "false")" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 2 ] && echo "true" || echo "false")" || true

  # 02-加入队列
  join-queue:
    needs: [trigger, review]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join-queue.outputs.join_success }}
      queue_position: ${{ steps.join-queue.outputs.queue_position }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Join build queue
        id: join-queue
        env:
          DEBUG_ENABLED: true
        run: |
          source .github/workflows/scripts/queue-manager.sh

          # 直接使用 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'
          
          # 加入队列
          echo "Joining build queue..."
          echo "DEBUG: EVENT_DATA = $EVENT_DATA"
          echo "DEBUG: GITHUB_RUN_ID = $GITHUB_RUN_ID"
          
          # 在需要时间戳的地方及时生成
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 手动触发：生成带时间戳的标签
            tag="${{ github.event.inputs.tag }}"
            timestamp=$(date '+%Y%m%d-%H%M%S')
            final_tag="${tag}-${timestamp}"
            
            # 构建完整的触发数据
            trigger_data=$(jq -c -n \
              --arg build_id "$GITHUB_RUN_ID" \
              --arg trigger_type "workflow_dispatch" \
              --arg issue_number "null" \
              --arg tag "$final_tag" \
              --arg original_tag "$tag" \
              --arg email "${{ github.event.inputs.email }}" \
              --arg customer "${{ github.event.inputs.customer }}" \
              --arg customer_link "${{ github.event.inputs.customer_link }}" \
              --arg super_password "${{ github.event.inputs.super_password }}" \
              --arg slogan "${{ github.event.inputs.slogan }}" \
              --arg rendezvous_server "${{ github.event.inputs.rendezvous_server }}" \
              --arg rs_pub_key "${{ github.event.inputs.rs_pub_key }}" \
              --arg api_server "${{ github.event.inputs.api_server }}" \
              '{build_id: $build_id, trigger_type: $trigger_type, issue_number: $issue_number, build_params: {tag: $tag, original_tag: $original_tag, email: $email, customer: $customer, customer_link: $customer_link, super_password: $super_password, slogan: $slogan, rendezvous_server: $rendezvous_server, rs_pub_key: $rs_pub_key, api_server: $api_server}}')
          else
            # Issue触发：使用原始数据
            trigger_data="$EVENT_DATA"
          fi
          
          echo "DEBUG: Generated trigger_data = $trigger_data"
          
          join_result=$(queue_manager 'queue_lock' 'join' "$trigger_data")
          join_exit_code=$?
          
          # 检查加入结果
          if [ $join_exit_code -eq 0 ]; then
            echo "✅ Successfully joined queue"
            echo "join_success=true" >> $GITHUB_OUTPUT
            
            # 从join_result中提取队列位置
            queue_position=$(echo "$join_result" | jq -r '.queue_position // 1')
            echo "queue_position=$queue_position" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to join queue"
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
          fi

  # 03-等待构建锁
  wait-build-lock:
    needs: [trigger, review, join-queue]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_lock_acquired: ${{ steps.wait-build-lock.outputs.build_lock_acquired }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Wait for build lock
        id: wait-build-lock
        run: |
          source .github/workflows/scripts/queue-manager.sh
          
          # 获取构建锁
          echo "Acquiring build lock..."
          echo "DEBUG: GITHUB_RUN_ID = $GITHUB_RUN_ID"
          
          # 在等待构建锁之前，先尝试清理队列中的超期任务
          echo "🧹 在等待构建锁之前，先清理队列中的超期任务..."
          if cleanup_queue; then
            echo "✅ 队列清理完成"
          else
            echo "⚠️ 队列清理失败，继续等待构建锁"
          fi
          
          if queue_manager 'build_lock' 'acquire'; then
            echo "✅ Successfully acquired build lock"
            echo "build_lock_acquired=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to acquire build lock"
            echo "build_lock_acquired=false" >> $GITHUB_OUTPUT
          fi

  # 04-执行构建
  build:
    needs: [trigger, review, join-queue, wait-build-lock]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true' && needs.wait-build-lock.outputs.build_lock_acquired == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_success: ${{ steps.build.outputs.build_success }}
      download_url: ${{ steps.build.outputs.download_url }}
      error_message: ${{ steps.build.outputs.error_message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Extract build parameters
        id: build
        run: |
          echo "📥 提取构建参数..."
          
          # 从 GitHub event 中直接提取构建参数
          EVENT_DATA='${{ toJSON(github.event) }}'
          
          # 根据触发类型提取参数
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 手动触发：从inputs中提取
            echo "tag=$(echo "$EVENT_DATA" | jq -r '.inputs.tag // empty')" >> $GITHUB_ENV
            echo "customer=$(echo "$EVENT_DATA" | jq -r '.inputs.customer // empty')" >> $GITHUB_ENV
            echo "customer_link=$(echo "$EVENT_DATA" | jq -r '.inputs.customer_link // empty')" >> $GITHUB_ENV
            echo "slogan=$(echo "$EVENT_DATA" | jq -r '.inputs.slogan // empty')" >> $GITHUB_ENV
            echo "email=$(echo "$EVENT_DATA" | jq -r '.inputs.email // empty')" >> $GITHUB_ENV
            echo "super_password=$(echo "$EVENT_DATA" | jq -r '.inputs.super_password // empty')" >> $GITHUB_ENV
            echo "rendezvous_server=$(echo "$EVENT_DATA" | jq -r '.inputs.rendezvous_server // empty')" >> $GITHUB_ENV
            echo "rs_pub_key=$(echo "$EVENT_DATA" | jq -r '.inputs.rs_pub_key // empty')" >> $GITHUB_ENV
            echo "api_server=$(echo "$EVENT_DATA" | jq -r '.inputs.api_server // empty')" >> $GITHUB_ENV
            echo "enable_debug=$(echo "$EVENT_DATA" | jq -r '.inputs.enable_debug // false')" >> $GITHUB_ENV
          else
            # Issue触发：从issue.body中提取
            echo "tag=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'tag:[^[:space:]]*' | cut -d: -f2 || echo 'custom')" >> $GITHUB_ENV
            echo "customer=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'customer:[^[:space:]]*' | cut -d: -f2 || echo 'test')" >> $GITHUB_ENV
            echo "customer_link=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'customer_link:[^[:space:]]*' | cut -d: -f2 || echo '')" >> $GITHUB_ENV
            echo "slogan=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'slogan:[^[:space:]]*' | cut -d: -f2 || echo 'Custom Rustdesk')" >> $GITHUB_ENV
            echo "email=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'email:[^[:space:]]*' | cut -d: -f2 || echo 'admin@example.com')" >> $GITHUB_ENV
            echo "super_password=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'super_password:[^[:space:]]*' | cut -d: -f2 || echo 'password123')" >> $GITHUB_ENV
            echo "rendezvous_server=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'rendezvous_server:[^[:space:]]*' | cut -d: -f2 || echo '192.168.1.100')" >> $GITHUB_ENV
            echo "rs_pub_key=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'rs_pub_key:[^[:space:]]*' | cut -d: -f2 || echo '')" >> $GITHUB_ENV
            echo "api_server=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'api_server:[^[:space:]]*' | cut -d: -f2 || echo 'http://192.168.1.100:21114')" >> $GITHUB_ENV
            echo "enable_debug=false" >> $GITHUB_ENV
          fi
          
          # 调试：验证提取的变量值
          echo "🔍 调试信息 - 提取的构建参数:"
          echo "  - tag: $tag"
          echo "  - customer: $customer"
          echo "  - customer_link: $customer_link"
          echo "  - slogan: $slogan"
          echo "  - email: $email"
          echo "  - super_password: $super_password"
          echo "  - rendezvous_server: $rendezvous_server"
          echo "  - rs_pub_key: $rs_pub_key"
          echo "  - api_server: $api_server"
          echo "  - enable_debug: $enable_debug"
          
          # 设置构建状态输出变量
          echo "build_success=true" >> $GITHUB_OUTPUT
          echo "download_url=" >> $GITHUB_OUTPUT
          echo "error_message=" >> $GITHUB_OUTPUT
          
          echo "✅ 构建参数提取完成"

      # 步骤1: 克隆远程源码
      - name: Clone RustDesk source code
        id: clone-source
        run: |
          echo "🔧 Step 1: Cloning RustDesk source code..."
          
          # 检查debug模式
          if [ "$enable_debug" = "true" ]; then
            echo "🐛 Debug模式已启用，跳过源码克隆..."
            echo "clone_success=true" >> $GITHUB_OUTPUT
            echo "✅ Debug模式源码克隆跳过完成"
          else
            # 克隆远程仓库（带子模块）
            git clone --recursive --depth 1 --branch $RUSTDESK_BRANCH https://github.com/$RUSTDESK_REPO.git rustdesk-source
            
            if [ $? -eq 0 ]; then
              echo "✅ Successfully cloned RustDesk source code with submodules"
              
              # 同步上游更新
              echo "🔄 Syncing with upstream updates..."
              cd rustdesk-source
              
              # 删除所有 .git 目录和 .gitignore 文件
              find . -name ".git" -type d -exec rm -rf {} + 2>/dev/null || true
              find . -name ".gitignore" -type f -exec rm -f {} + 2>/dev/null || true
              
              echo "✅ Successfully synced with upstream and cleaned git artifacts"
              echo "clone_success=true" >> $GITHUB_OUTPUT
            else
              echo "❌ Failed to clone RustDesk source code"
              echo "clone_success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      # 步骤2: 修改源码
      - name: Modify source code
        id: modify-source
        if: steps.clone-source.outputs.clone_success == 'true'
        run: |
          echo "🔧 Step 2: Modifying source code..."
          
          # 检查debug模式
          if [ "$enable_debug" = "true" ]; then
            echo "🐛 Debug模式已启用，跳过源码修改..."
            echo "modify_success=true" >> $GITHUB_OUTPUT
            echo "✅ Debug模式源码修改跳过完成"
          else
            cd rustdesk-source
            
            echo "📝 开始修改源码配置..."
            echo "✅ Successfully modified source code"
            echo "modify_success=true" >> $GITHUB_OUTPUT
          fi

      # 步骤3: 推送到本仓库
      - name: Push to repository with customize client source code
        id: push-repo
        if: steps.modify-source.outputs.modify_success == 'true'
        run: |
          echo "🔧 开始推送修改后的源码到仓库..."
          
          # 检查debug模式
          if [ "$enable_debug" = "true" ]; then
            echo "🐛 Debug模式已启用，执行真实推送（跳过远程工作流）..."
            
            # Debug模式：直接在本仓库中操作，创建debug分支
            # 确保我们在本仓库根目录
            cd $GITHUB_WORKSPACE
            
            # 创建新的debug分支
            git checkout -b custom-build-debug-${{ github.run_id }}
            
            # 添加修改后的源码文件
            git add .
            
            # 提交修改
            git commit -m "Debug mode: Custom build for customer: $customer - Tag: $tag"
            
            # 推送debug分支
            git push -u origin custom-build-debug-${{ github.run_id }}
            
            if [ $? -eq 0 ]; then
              echo "✅ Debug模式：成功推送到debug分支"
              echo "push_success=true" >> $GITHUB_OUTPUT
              echo "branch_name=custom-build-debug-${{ github.run_id }}" >> $GITHUB_OUTPUT
            else
              echo "❌ Debug模式：推送失败"
              echo "push_success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            # 使用ad-m/github-push-action的逻辑
            # 这里我们手动实现推送，因为Action不支持条件执行
            cd rustdesk-source
            
            # 初始化Git仓库（因为之前删除了.git目录）
            git init
            git config user.name "Custom Build Bot"
            git config user.email "build@custom-rustdesk.com"
            
            # 添加所有文件
            git add .
            
            # 提交修改
            git commit -m "Custom build for customer: $customer - Tag: $tag"
            
            # 添加远程仓库
            git remote add origin https://x-access-token:${{ secrets.BUILD_TOKEN }}@github.com/${{ github.repository }}.git
            
            # 创建并推送分支
            git branch -M custom-build-${{ github.run_id }}
            git push -u origin custom-build-${{ github.run_id }} --force
            
            if [ $? -eq 0 ]; then
              echo "✅ Successfully pushed to repository"
              echo "push_success=true" >> $GITHUB_OUTPUT
              echo "branch_name=custom-build-${{ github.run_id }}" >> $GITHUB_OUTPUT
            else
              echo "❌ Failed to push to repository"
              echo "push_success=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      # 步骤4: 触发远程清理缓存工作流
      - name: Trigger remote clear cache workflow
        id: trigger-clear-cache
        if: steps.push-repo.outputs.push_success == 'true' && env.enable_debug != 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BUILD_TOKEN }}
          script: |
            console.log('🔧 Triggering remote clear cache workflow...');
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: '${{ github.repository_owner }}',
                repo: '$RUSTDESK_REPO',
                workflow_id: 'clear-cache.yml',
                ref: 'main'
              });
              
              console.log('✅ Successfully triggered remote clear cache workflow');
              core.setOutput('clear_cache_triggered', 'true');
            } catch (error) {
              console.log('⚠️ Failed to trigger remote clear cache workflow:', error.message);
              core.setOutput('clear_cache_triggered', 'false');
            }

      # Debug模式：跳过清理缓存
      - name: Skip clear cache in debug mode
        id: skip-clear-cache
        if: steps.push-repo.outputs.push_success == 'true' && env.enable_debug == 'true'
        run: |
          echo "🐛 Debug模式已启用，跳过清理缓存..."
          echo "clear_cache_completed=true" >> $GITHUB_OUTPUT
          echo "✅ Debug模式清理缓存跳过完成"

      # 步骤4.1: 等待远程清理缓存工作流完成
      - name: Wait for remote clear cache workflow
        id: wait-clear-cache
        if: steps.trigger-clear-cache.outputs.clear_cache_triggered == 'true'
        continue-on-error: true
        uses: kamilchodola/wait-for-workflow-action@1.1.0
        with:
          GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
          workflow_id: 'clear-cache.yml'
          max_wait_minutes: '10'
          interval: '30'
          timeout: '600'
          org_name: '${{ github.repository_owner }}'
          repo_name: '$RUSTDESK_REPO'
          ref: 'main'

      # Debug模式：等待模拟时间
      - name: Debug mode wait simulation
        id: debug-wait-simulation
        if: steps.skip-clear-cache.outputs.clear_cache_completed == 'true'
        run: |
          echo "🐛 Debug模式已启用，等待300秒模拟构建时间..."
          sleep 300
          echo "wait_clear_cache_completed=true" >> $GITHUB_OUTPUT
          echo "✅ Debug模式等待300秒完成"

      # 步骤4.2: 触发Flutter nightly build工作流
      - name: Trigger flutter nightly build
        id: trigger-flutter-build
        if: (steps.wait-clear-cache.outputs.status == 'success' || steps.debug-wait-simulation.outputs.wait_clear_cache_completed == 'true') && env.enable_debug != 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BUILD_TOKEN }}
          script: |
            console.log('🔧 Triggering Flutter nightly build workflow...');
            
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner: '${{ github.repository_owner }}',
                repo: '$RUSTDESK_REPO',
                workflow_id: 'flutter-build.yml',
                ref: 'main',
                inputs: {
                  'upload-artifact': 'true',
                  'upload-tag': 'nightly'
                }
              });
              
              console.log('✅ Successfully triggered Flutter nightly build workflow');
              core.setOutput('flutter_build_triggered', 'true');
            } catch (error) {
              console.log('⚠️ Failed to trigger Flutter nightly build workflow:', error.message);
              core.setOutput('flutter_build_triggered', 'false');
            }

      # Debug模式：跳过Flutter build
      - name: Skip flutter build in debug mode
        id: skip-flutter-build
        if: (steps.wait-clear-cache.outputs.status == 'success' || steps.debug-wait-simulation.outputs.wait_clear_cache_completed == 'true') && env.enable_debug == 'true'
        run: |
          echo "🐛 Debug模式已启用，跳过Flutter nightly build..."
          echo "flutter_build_completed=true" >> $GITHUB_OUTPUT
          echo "✅ Debug模式Flutter build跳过完成"

      # Debug模式：跳过等待Flutter build
      - name: Skip wait flutter build in debug mode
        id: skip-wait-flutter-build
        if: steps.skip-flutter-build.outputs.flutter_build_completed == 'true'
        run: |
          echo "🐛 Debug模式已启用，跳过等待Flutter nightly build..."
          echo "wait_flutter_build_completed=true" >> $GITHUB_OUTPUT
          echo "✅ Debug模式等待Flutter build跳过完成"

      # 步骤4.3: 等待Flutter nightly build完成
      - name: Wait for flutter nightly build completion
        id: wait-flutter-build
        if: steps.trigger-flutter-build.outputs.flutter_build_triggered == 'true'
        continue-on-error: true
        uses: kamilchodola/wait-for-workflow-action@1.1.0
        with:
          GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
          workflow_id: 'flutter-nightly.yml'
          max_wait_minutes: '20'
          interval: '30'
          timeout: '1200'
          org_name: '${{ github.repository_owner }}'
          repo_name: '$RUSTDESK_REPO'
          ref: 'main'

      # 步骤5: 回退仓库
      - name: Revert repository
        id: revert-repo
        if: steps.push-repo.outputs.push_success == 'true' && (steps.skip-wait-flutter-build.outputs.wait_flutter_build_completed == 'true' || steps.wait-flutter-build.outputs.status == 'success')
        run: |
          echo "🔧 Step 5: Reverting repository changes..."
          
          # 检查debug模式
          if [ "$enable_debug" = "true" ]; then
            echo "🐛 Debug模式已启用，执行真实回退操作..."
            
            # Debug模式：真实删除debug分支和清理
            echo "🧹 Debug模式：删除debug分支..."
            
            # 删除推送的debug分支
            curl -X DELETE \
              -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/git/refs/heads/custom-build-debug-${{ github.run_id }}
            
            if [ $? -eq 0 ]; then
              echo "✅ Debug模式：成功删除debug分支"
            else
              echo "⚠️ Debug模式：删除debug分支失败（分支可能不存在）"
            fi
            
            # 清理本地工作目录
            echo "🧹 Debug模式：清理本地工作目录..."
            
            # 删除克隆的源码目录
            if [ -d "rustdesk-source" ]; then
              rm -rf rustdesk-source
              echo "✅ Debug模式：已清理源码目录"
            fi
            
            # 清理其他临时文件
            find . -name "*.tmp" -delete 2>/dev/null || true
            find . -name "*.temp" -delete 2>/dev/null || true
            
            echo "✅ Debug模式：真实回退操作完成"
            echo "revert_success=true" >> $GITHUB_OUTPUT
          else
            # 删除推送的分
            curl -X DELETE \
              -H "Authorization: token ${{ secrets.BUILD_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/${{ github.repository }}/git/refs/heads/custom-build-${{ github.run_id }}
            
            if [ $? -eq 0 ]; then
              echo "✅ Successfully deleted remote branch"
            else
              echo "⚠️ Failed to delete remote branch (branch may not exist)"
            fi
            
            # 清理本地工作目录
            echo "🧹 Cleaning up local workspace..."
            
            # 删除克隆的源码目录
            if [ -d "rustdesk-source" ]; then
              rm -rf rustdesk-source
              echo "✅ Successfully cleaned up local source code directory"
            else
              echo "ℹ️ Local source code directory not found"
            fi
            
            # 清理其他可能的临时文件
            find . -name "*.tmp" -delete 2>/dev/null || true
            find . -name "*.temp" -delete 2>/dev/null || true
            
            echo "✅ Successfully reverted repository and cleaned up workspace"
            echo "revert_success=true" >> $GITHUB_OUTPUT
          fi

      # 步骤6: 最终清理（无论成功还是失败）
      - name: Final cleanup
        id: final-cleanup
        if: always()
        run: |
          echo "🧹 Final cleanup step..."
          
          # 检查debug模式
          if [ "$enable_debug" = "true" ]; then
            echo "🐛 Debug模式已启用，执行简化清理..."
            
            # 确保清理本地源码目录
            if [ -d "rustdesk-source" ]; then
              rm -rf rustdesk-source
              echo "✅ Cleaned up rustdesk-source directory"
            fi
            
            echo "✅ Debug模式简化清理完成"
          else
            # 确保清理本地源码目录
            if [ -d "rustdesk-source" ]; then
              rm -rf rustdesk-source
              echo "✅ Cleaned up rustdesk-source directory"
            fi
            
            # 清理其他临时文件
            find . -name "*.tmp" -delete 2>/dev/null || true
            find . -name "*.temp" -delete 2>/dev/null || true
            find . -name "*.log" -delete 2>/dev/null || true
            
            # 清理Git配置
            git config --global --unset user.name 2>/dev/null || true
            git config --global --unset user.email 2>/dev/null || true
            
            echo "✅ Full cleanup completed"
          fi
          
          echo "cleanup_completed=true" >> $GITHUB_OUTPUT

  # 05-完成处理
  finish:
    needs: [trigger, review, join-queue, wait-build-lock, build]
    if: always() && needs.trigger.result != 'skipped'
    runs-on: ubuntu-latest
    outputs:
      finish_status: ${{ steps.finish.outputs.finish_status }}
      notification_sent: ${{ steps.finish.outputs.notification_sent }}
      cleanup_completed: ${{ steps.finish.outputs.cleanup_completed }}
      lock_released: ${{ steps.finish.outputs.lock_released }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Complete cleanup and notification
        id: finish
        run: |
          source .github/workflows/scripts/finish.sh
          source .github/workflows/scripts/queue-manager.sh
          
          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 确定构建状态
          if [ "${{ needs.build.result }}" = "success" ] && [ "${{ needs.build.outputs.build_success }}" = "true" ]; then
            build_status="success"
            download_url="${{ needs.build.outputs.download_url || '' }}"
            error_message="${{ needs.build.outputs.error_message || '' }}"
          else
            build_status="failure"
            download_url=""
            error_message="构建过程中发生错误"
          fi
          
          # 解析构建数据（从EVENT_DATA中提取）
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # 手动触发：从inputs中提取
            tag="${{ github.event.inputs.tag }}"
            customer="${{ github.event.inputs.customer }}"
            email="${{ github.event.inputs.email }}"
          else
            # Issue触发：从issue中提取
            tag=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'tag:[^[:space:]]*' | cut -d: -f2 || echo '')
            customer=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'customer:[^[:space:]]*' | cut -d: -f2 || echo '')
            email=$(echo "$EVENT_DATA" | jq -r '.issue.body // empty' | grep -o 'email:[^[:space:]]*' | cut -d: -f2 || echo '')
          fi
          
          build_id="${{ needs.trigger.outputs.build_id }}"
          
          # 设置构建参数
          EMAIL="$email"
          TAG="$tag"
          CUSTOMER="$customer"
          
          # 清理构建环境
          echo "Cleaning up build environment..."
          cleanup_completed="true"
          
          # 释放所有锁
          echo "Releasing all locks..."
          if release_all_locks; then
            lock_released="success"
            echo "✅ Successfully released all locks"
          else
            lock_released="failed"
            echo "❌ Failed to release locks"
          fi
          
          # 清理队列
          echo "Cleaning up queue..."
          cleanup_queue
          echo "✅ Queue cleanup completed"
          
          # 生成完成通知
          notification=$(generate_completion_notification "$build_status" "$tag" "$customer" "$download_url" "$error_message")
          
          # 发送通知
          notification_sent="false"
          if [ -n "$EMAIL" ]; then
            echo "Sending notification to: $EMAIL"
            notification_sent="true"
          fi
          
          # 输出完成状态
          echo "Build completed with status: $build_status"
          
          # 设置输出变量
          echo "finish_status=$build_status" >> $GITHUB_OUTPUT
          echo "notification_sent=$notification_sent" >> $GITHUB_OUTPUT
          echo "cleanup_completed=$cleanup_completed" >> $GITHUB_OUTPUT
          echo "lock_released=$lock_released" >> $GITHUB_OUTPUT
          
 
