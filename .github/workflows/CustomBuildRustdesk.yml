name: Custom Rustdesk Build Workflow

on:
  # Issue 触发
  issues:
    types: [opened]
  
  # 手动触发
  workflow_dispatch:
    inputs:
      tag:
        description: '构建标签'
        required: true
        default: 'custom'
      customer:
        description: '客户名称'
        required: true
        default: 'test'
      customer_link:
        description: '客户链接'
        required: false
        default: ''
      slogan:
        description: '标语'
        required: false
        default: 'Custom Rustdesk'
      email:
        description: '邮箱地址'
        required: true
        default: 'admin@example.com'
      super_password:
        description: '超级密码'
        required: true
        default: 'password123'
      rendezvous_server:
        description: 'Rendezvous服务地址'
        required: true
        default: '192.168.1.100'
      rs_pub_key:
        description: 'RS公钥'
        required: false
        default: ''
      api_server:
        description: 'API服务地址'
        required: true
        default: 'http://192.168.1.100:21114'
      enable_debug:
        description: '启用调试模式（仅手动触发时有效）'
        required: false
        default: true
        type: boolean

permissions:
  issues: write
  contents: read
  actions: read

env:
  GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
  ENCRYPTION_KEY: ${{ secrets.ENCRYPTION_KEY }}
  # 队列管理配置
  QUEUE_ISSUE_NUMBER: '1'
  # 调试配置 - 默认不开启调试，只在手动触发时可通过input控制
  DEBUG_ENABLED: true
  # 默认值配置
  DEFAULT_TAG: ${{ secrets.DEFAULT_TAG }}
  DEFAULT_EMAIL: ${{ secrets.DEFAULT_EMAIL }}
  DEFAULT_CUSTOMER: ${{ secrets.DEFAULT_CUSTOMER }}
  DEFAULT_CUSTOMER_LINK: ${{ secrets.DEFAULT_CUSTOMER_LINK }}
  DEFAULT_SUPER_PASSWORD: ${{ secrets.DEFAULT_SUPER_PASSWORD }}
  DEFAULT_SLOGAN: ${{ secrets.DEFAULT_SLOGAN }}
  DEFAULT_RENDEZVOUS_SERVER: ${{ secrets.DEFAULT_RENDEZVOUS_SERVER }}
  DEFAULT_RS_PUB_KEY: ${{ secrets.DEFAULT_RS_PUB_KEY }}
  DEFAULT_API_SERVER: ${{ secrets.DEFAULT_API_SERVER }}

jobs:
  # 00-触发处理 - 提取和验证参数
  trigger:
    runs-on: ubuntu-latest
    outputs:
      build_id: ${{ steps.trigger.outputs.build_id }}
      trigger_data: ${{ steps.trigger.outputs.trigger_data }}
      validation_passed: ${{ steps.trigger.outputs.validation_passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Process trigger and validate parameters
        id: trigger
        env:
          GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          source .github/workflows/scripts/trigger.sh
          
          # 使用环境变量传递事件数据
          export EVENT_DATA='${{ toJSON(github.event) }}'
          
          # 根据触发类型提取参数
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            params=$(trigger_manager "extract-workflow-dispatch" "$EVENT_DATA")
            eval "$params"
          else
            params=$(trigger_manager "extract-issue" "$EVENT_DATA")
            eval "$params"
          fi
          
          # 应用默认值
          final_params=$(trigger_manager "apply-defaults" "$EVENT_DATA")
          eval "$final_params"
          
          # 处理tag时间戳
          final_tag=$(trigger_manager "process-tag" "$EVENT_DATA")
          
          # 生成最终JSON数据
          final_data=$(trigger_manager "generate-data" "$EVENT_DATA" "$final_tag")
          
          # 验证参数
          validation_result=$(trigger_manager "validate-parameters" "$final_data")
          validation_exit_code=$?
          
          # 如果是issue触发，暂时不清理issue内容，等待验证结果
          # issue清理将在验证通过后由review阶段处理
          
          # 输出到GitHub Actions
          trigger_manager "output-to-github" "$final_data"
          
          # 设置验证结果
          if [ $validation_exit_code -eq 0 ]; then
            echo "validation_passed=true" >> $GITHUB_OUTPUT
          else
            echo "validation_passed=false" >> $GITHUB_OUTPUT
          fi

  # 01-审核验证 - 处理需要审核的情况
  review:
    needs: trigger
    if: needs.trigger.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    outputs:
      review_passed: ${{ steps.review.outputs.review_passed }}
      review_reason: ${{ steps.review.outputs.review_reason }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Review and validate
        id: review
        shell: bash
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
          GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
        run: |
          source .github/workflows/scripts/review.sh

          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 设置审核数据
          echo "TRIGGER_OUTPUT=$TRIGGER_DATA" >> $GITHUB_ENV
          
          # 验证参数
          validation_result=$(review_manager "validate" "$EVENT_DATA" "$TRIGGER_DATA" || true)
          validation_exit_code=$?
          
          if [ $validation_exit_code -ne 0 ]; then
            # 参数验证失败，处理拒绝
            review_manager "handle-rejection" "$EVENT_DATA" "$TRIGGER_DATA" "$validation_result" || true
            echo "review_passed=false" >> $GITHUB_OUTPUT
            echo "review_reason=参数验证失败" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 检查是否需要审核
          need_review=$(review_manager "need-review" "$EVENT_DATA" "$TRIGGER_DATA" || true)
          
          # 如果是issue触发，无论是否需要审核，都清理issue内容
          if [ "${{ github.event_name }}" = "issues" ]; then
            source .github/workflows/scripts/trigger.sh
            
            # 从TRIGGER_DATA中提取参数用于清理
            final_tag_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.tag // empty')
            original_tag_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.original_tag // empty')
            customer_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.customer // empty')
            slogan_param=$(echo "$TRIGGER_DATA" | jq -r '.build_params.slogan // empty')
            
            cleaned_body=$(trigger_manager "clean-issue" "$final_tag_param" "$original_tag_param" "$customer_param" "$slogan_param")
            issue_number="${{ github.event.issue.number }}"
            trigger_manager "update-issue" "$issue_number" "$cleaned_body"
          fi
          
          if [ "$need_review" = "true" ]; then
            # 需要审核，在issue中回复需要审核的信息
            if [ "${{ github.event_name }}" = "issues" ]; then
              source .github/workflows/scripts/issue-templates.sh
              review_comment=$(generate_review_required_template "${{ github.run_id }}" "${{ github.event.issue.number }}" "$TRIGGER_DATA")
              source .github/workflows/scripts/issue-manager.sh
              add_issue_comment "${{ github.event.issue.number }}" "$review_comment" || true
            fi
            
            # 处理审核流程
            review_result=$(review_manager "handle-review" "$EVENT_DATA" "$TRIGGER_DATA" || true)
            review_exit_code=$?
            
            if [ $review_exit_code -eq 0 ]; then
              # 审核通过
              echo "review_passed=true" >> $GITHUB_OUTPUT
              echo "review_reason=" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 1 ]; then
              # 审核被拒绝
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=审核被拒绝" >> $GITHUB_OUTPUT
            elif [ $review_exit_code -eq 2 ]; then
              # 审核超时
              echo "review_passed=false" >> $GITHUB_OUTPUT
              echo "review_reason=审核超时" >> $GITHUB_OUTPUT
            fi
          else
            # 不需要审核，直接通过
            echo "review_passed=true" >> $GITHUB_OUTPUT
            echo "review_reason=" >> $GITHUB_OUTPUT
          fi
          
          # 输出数据（传递审核结果）
          review_manager "output-data" "$EVENT_DATA" "$TRIGGER_DATA" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 1 ] && echo "true" || echo "false")" "$([ "$need_review" = "true" ] && [ $review_exit_code -eq 2 ] && echo "true" || echo "false")" || true

  # 02-三锁队列管理 - 使用三锁架构加入队列
  join-queue:
    needs: [trigger, review]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true'
    env:
      TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
      BUILD_ID: ${{ needs.trigger.outputs.build_id }}
      GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
      GITHUB_REPOSITORY: ${{ github.repository }}
    runs-on: ubuntu-latest
    outputs:
      join_success: ${{ steps.join-queue.outputs.join_success }}
      queue_position: ${{ steps.join-queue.outputs.queue_position }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Join build queue with triple lock
        id: join-queue
        run: |
          source .github/workflows/scripts/queue-manager.sh

          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 使用通用函数自动确定issue_number和build_id
          eval $(queue_manager_determine_ids "$EVENT_DATA" "$TRIGGER_DATA" "${{ github.run_id }}" "${{ github.event_name }}")

          echo "Issue Number: $ISSUE_NUMBER"
          echo "Build ID: $BUILD_ID"

          # 使用三锁架构加入队列
          echo "Starting triple lock queue join process..."
          join_result=$(queue_manager "join" "$ISSUE_NUMBER" "$TRIGGER_DATA" "5")
          join_exit_code=$?
          
          # 检查加入结果
          if [ $join_exit_code -eq 0 ]; then
            echo "✅ Successfully joined queue with triple lock"
            echo "join_success=true" >> $GITHUB_OUTPUT
            
            # 从join_result中提取队列位置
            queue_position=$(echo "$join_result" | jq -r '.queue_position // 1')
            echo "queue_position=$queue_position" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to join queue"
            echo "join_success=false" >> $GITHUB_OUTPUT
            echo "queue_position=-1" >> $GITHUB_OUTPUT
          fi

  # 03-等待构建锁 - 使用三锁架构获取构建权限
  wait-build-lock:
    needs: [trigger, review, join-queue]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true'
    env:
      TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
      BUILD_ID: ${{ needs.trigger.outputs.build_id }}
      GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
      GITHUB_REPOSITORY: ${{ github.repository }}
    runs-on: ubuntu-latest
    outputs:
      build_lock_acquired: ${{ steps.wait-build-lock.outputs.build_lock_acquired }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Wait for build lock with triple lock
        id: wait-build-lock
        run: |
          source .github/workflows/scripts/queue-manager.sh

          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 使用通用函数自动确定issue_number和build_id
          eval $(queue_manager_determine_ids "$EVENT_DATA" "$TRIGGER_DATA" "${{ github.run_id }}" "${{ github.event_name }}")

          echo "Issue Number: $ISSUE_NUMBER"
          echo "Build ID: $BUILD_ID"
          
          # 使用三锁架构获取构建锁
          lock_result=$(queue_manager "acquire" "$BUILD_ID" "5")

          # 检查获取锁的结果
          if [ $? -eq 0 ]; then
            echo "✅ Successfully acquired build lock with triple lock"
            echo "build_lock_acquired=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Failed to acquire build lock"
            echo "build_lock_acquired=false" >> $GITHUB_OUTPUT
          fi

  # 04-执行构建 - 构建过程
  build:
    needs: [trigger, review, join-queue, wait-build-lock]
    if: needs.trigger.outputs.validation_passed == 'true' && needs.review.outputs.review_passed == 'true' && needs.join-queue.outputs.join_success == 'true' && needs.wait-build-lock.outputs.build_lock_acquired == 'true'
    runs-on: ubuntu-latest
    outputs:
      build_success: ${{ steps.build.outputs.build_success }}
      download_url: ${{ steps.build.outputs.download_url }}
      error_message: ${{ steps.build.outputs.error_message }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Execute build process
        id: build
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
          BUILD_ID: ${{ needs.trigger.outputs.build_id }}
          GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          source .github/workflows/scripts/build.sh
          
          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 提取数据
          extracted_data=$(build_manager "extract-data" "$TRIGGER_DATA")
          extract_exit_code=$?
          
          if [ $extract_exit_code -ne 0 ]; then
            echo "❌ Failed to extract build data"
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "download_url=" >> $GITHUB_OUTPUT
            echo "error_message=Failed to extract build parameters" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # 处理构建数据
          processed_data=$(build_manager "process-data" "$extracted_data")
          process_exit_code=$?
          
          if [ $process_exit_code -ne 0 ]; then
            echo "❌ Failed to process build data"
            echo "build_success=false" >> $GITHUB_OUTPUT
            echo "download_url=" >> $GITHUB_OUTPUT
            echo "error_message=Failed to process build data" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # 输出构建数据
          build_manager "output-data" "$processed_data"

  # 05-完成处理 - 清理和通知
  finish:
    needs: [trigger, review, join-queue, wait-build-lock, build]
    if: always() && needs.trigger.result != 'skipped'
    runs-on: ubuntu-latest
    outputs:
      finish_status: ${{ steps.finish.outputs.finish_status }}
      notification_sent: ${{ steps.finish.outputs.notification_sent }}
      cleanup_completed: ${{ steps.finish.outputs.cleanup_completed }}
      lock_released: ${{ steps.finish.outputs.lock_released }}
      finish_validation_passed: ${{ steps.finish.outputs.finish_validation_passed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Complete cleanup and notification
        id: finish
        env:
          TRIGGER_DATA: ${{ needs.trigger.outputs.trigger_data }}
          BUILD_ID: ${{ needs.trigger.outputs.build_id }}
          GITHUB_TOKEN: ${{ secrets.BUILD_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          source .github/workflows/scripts/finish.sh
          
          # 重新获取 github.event
          EVENT_DATA='${{ toJSON(github.event) }}'

          # 确定构建状态
          if [ "${{ needs.build.result }}" = "success" ] && [ "${{ needs.build.outputs.build_success }}" = "true" ]; then
            build_status="success"
            download_url="${{ needs.build.outputs.download_url || '' }}"
            error_message="${{ needs.build.outputs.error_message || '' }}"
          else
            build_status="failure"
            download_url=""
            error_message="构建过程中发生错误"
          fi
          
          # 解析构建数据（从build_params中提取）
          tag=$(echo "$TRIGGER_DATA" | jq -r '.build_params.tag // empty')
          customer=$(echo "$TRIGGER_DATA" | jq -r '.build_params.customer // empty')
          email=$(echo "$TRIGGER_DATA" | jq -r '.build_params.email // empty')
          build_id="$BUILD_ID"
          
          # 设置完成环境
          finish_manager "setup-environment" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message"
          setup_exit_code=$?
          
          # 获取构建参数（如果需要解密）
          if [ "$build_status" = "success" ]; then
            build_params=$(finish_manager "get-params" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message" "$build_id")
            get_params_exit_code=$?
            if [ $get_params_exit_code -eq 0 ]; then
              eval "$build_params"
            else
              debug "warning" "Failed to get build parameters, using fallback values"
              # 使用从TRIGGER_DATA中提取的参数作为备选
              EMAIL="$email"
              TAG="$tag"
              CUSTOMER="$customer"
            fi
          else
            # 构建失败时也尝试获取参数用于通知
            build_params=$(finish_manager "get-params" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message" "$build_id")
            get_params_exit_code=$?
            if [ $get_params_exit_code -eq 0 ]; then
              eval "$build_params"
            else
              # 使用从TRIGGER_DATA中提取的参数作为备选
              EMAIL="$email"
              TAG="$tag"
              CUSTOMER="$customer"
            fi
          fi
          
          # 清理构建环境
          finish_manager "cleanup" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message" "$build_id"
          cleanup_exit_code=$?
          if [ $cleanup_exit_code -eq 0 ]; then
            cleanup_completed="true"
          else
            cleanup_completed="false"
            debug "warning" "Build environment cleanup failed"
          fi
          
          # 释放三锁架构的所有锁
          lock_released_output=$(finish_manager "release-triple-lock" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message" "$build_id")
          lock_release_exit_code=$?
          
          # 解析锁释放结果
          if echo "$lock_released_output" | grep -q "lock_released="; then
            lock_released=$(echo "$lock_released_output" | grep "lock_released=" | cut -d'=' -f2)
          else
            lock_released="unknown"
          fi
          
          # 检查是否有部分锁释放失败
          if echo "$lock_released_output" | grep -q "failed_locks="; then
            failed_locks=$(echo "$lock_released_output" | grep "failed_locks=" | cut -d'=' -f2)
            debug "warning" "Some locks failed to release: $failed_locks"
          fi
          
          # 检查并重置版本号（当三锁为空时）
          version_reset_output=$(finish_manager "check-version-reset" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message")
          version_reset_exit_code=$?
          
          # 解析版本重置结果
          if echo "$version_reset_output" | grep -q "version_reset="; then
            version_reset=$(echo "$version_reset_output" | grep "version_reset=" | cut -d'=' -f2)
            if [ "$version_reset" = "true" ]; then
              debug "success" "Version numbers have been reset"
            else
              debug "log" "Version reset not needed or failed"
            fi
          fi
          
          # 输出完成数据（通知状态将在后续设置）
          finish_manager "output-data" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message" "false" "$cleanup_completed" "$lock_released"
          
          # 设置输出变量
          echo "finish_status=$build_status" >> $GITHUB_OUTPUT
          echo "notification_sent=$notification_sent" >> $GITHUB_OUTPUT
          echo "cleanup_completed=$cleanup_completed" >> $GITHUB_OUTPUT
          echo "lock_released=$lock_released" >> $GITHUB_OUTPUT
          
          # 生成完成通知（在结果输出后进行）
          notification=$(generate_completion_notification "$build_status" "$tag" "$customer" "$download_url" "$error_message")
          
          # 发送通知（无论成功还是失败都发送）
          notification_sent="false"
          if [ -n "$EMAIL" ]; then
            subject="Custom Rustdesk Build - $build_status"
            finish_manager "send-notification" "$TRIGGER_DATA" "$build_status" "$download_url" "$error_message" "$EMAIL" "$subject" "$notification"
            notification_exit_code=$?
            if [ $notification_exit_code -eq 0 ]; then
              notification_sent="true"
              # 更新输出变量
              echo "notification_sent=true" >> $GITHUB_OUTPUT
            else
              debug "warning" "Failed to send notification"
            fi
          else
            debug "warning" "No email address available for notification"
          fi 
          
 
