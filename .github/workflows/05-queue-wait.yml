name: 05 - Queue Wait

on:
  workflow_run:
    workflows: ["04 - Queue Join"]
    types: [completed]

# Ê∑ªÂä†ÊùÉÈôêÈÖçÁΩÆ
permissions:
  issues: write
  contents: read

jobs:
  queue_wait:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Get queue join workflow data
        id: get_data
        run: |
          # Ëé∑ÂèñÂä†ÂÖ•ÈòüÂàóÂ∑•‰ΩúÊµÅÁöÑÊï∞ÊçÆ
          QUEUE_JOIN_RUN_ID="${{ github.event.workflow_run.id }}"
          
          # Ëé∑ÂèñÂä†ÂÖ•ÈòüÂàóÂ∑•‰ΩúÊµÅÁöÑËæìÂá∫
          QUEUE_POSITION=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/$QUEUE_JOIN_RUN_ID/jobs" | \
            jq -r '.jobs[0].steps[] | select(.name == "Join queue") | .outputs.queue_position // empty')
          
          if [ -z "$QUEUE_POSITION" ]; then
            echo "‚ùå Failed to get queue position"
            exit 1
          fi
          
          echo "QUEUE_POSITION=$QUEUE_POSITION" >> $GITHUB_ENV
          echo "queue_position=$QUEUE_POSITION" >> $GITHUB_OUTPUT
      
      - name: Wait in queue
        run: |
          # Á≠âÂæÖËΩÆÂà∞Ëá™Â∑±ÁöÑ‰ΩçÁΩÆÂπ∂Ëé∑ÂèñÊûÑÂª∫ÈîÅ
          echo "Waiting in queue and for build lock..."
          
          # Âä†ËΩΩÂÖ±‰∫´Â∑•ÂÖ∑ÂáΩÊï∞
          source .github/workflows/shared/github-utils.yml
          
          START_TIME=$(date +%s)
          TIMEOUT=21600  # 6Â∞èÊó∂Ë∂ÖÊó∂
          
          # Ëé∑ÂèñÂΩìÂâçÊûÑÂª∫Ê†áËØÜÁ¨¶
          CURRENT_BUILD_ID="${{ github.run_id }}"
          echo "Current build ID: $CURRENT_BUILD_ID"
          
          # Â¶ÇÊûúÂàöÂàöÂä†ÂÖ•ÈòüÂàó‰∏î‰ΩçÁΩÆÊòØ1ÔºåÁõ¥Êé•ÂºÄÂßãÊûÑÂª∫
          if [ "$QUEUE_POSITION" = "1" ]; then
            echo "‚úÖ Build is at front of queue, proceeding to build..."
            exit 0
          fi
          
          # ÈáçËØïÊú∫Âà∂ÂèÇÊï∞
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          # Âê¶ÂàôÁ≠âÂæÖÂπ∂Ê£ÄÊü•ÈòüÂàóÁä∂ÊÄÅ
          while [ $(($(date +%s) - START_TIME)) -lt $TIMEOUT ]; do
            echo "Checking queue position and lock status... ($(($(date +%s) - START_TIME))s elapsed)"
            
            # Ëé∑ÂèñÈòüÂàóÊï∞ÊçÆ
            QUEUE_MANAGER_ISSUE="1"
            QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
            QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
            
            # Â¶ÇÊûúÊèêÂèñÂ§±Ë¥•ÔºåÁõ¥Êé•ÈÄÄÂá∫
            if [ -z "$QUEUE_DATA" ]; then
              echo "‚ùå Failed to extract queue JSON, aborting."
              exit 1
            fi
            
            # È™åËØÅJSONÊ†ºÂºè
            if ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
              echo "‚ùå Invalid JSON format in queue data, aborting."
              exit 1
            fi
            
            # Âº∫Âà∂ÂçïË°åJSON
            QUEUE_DATA=$(echo "$QUEUE_DATA" | jq -c .)
            
            # Ê£ÄÊü•ÂΩìÂâçÊûÑÂª∫ÊòØÂê¶Âú®ÈòüÂàó‰∏≠
            ISSUE_IN_QUEUE=$(echo "$QUEUE_DATA" | \
              jq -r --arg issue_number "$CURRENT_BUILD_ID" \
              '.queue | map(.issue_number) | contains([$issue_number])')
            
            if [ "$ISSUE_IN_QUEUE" != "true" ]; then
              echo "‚ùå Build not found in queue, exiting..."
              exit 1
            fi
            
            # Ê£ÄÊü•ÊòØÂê¶ÊòØÈ¶ñ‰Ωç
            CURRENT_POSITION=$(echo "$QUEUE_DATA" | \
              jq -r --arg issue_number "$CURRENT_BUILD_ID" \
              '.queue | sort_by(.join_time) | map(.issue_number) | index($issue_number) // empty | . + 1')
            
            if [ "$CURRENT_POSITION" = "1" ]; then
              # Ê£ÄÊü•ÈîÅÁä∂ÊÄÅ
              LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
              
              if [ "$LOCK_RUN_ID" = "null" ]; then
                echo "‚úÖ At front of queue and no lock, attempting to acquire lock..."
                
                # ÈáçËØïËé∑ÂèñÈîÅ
                for lock_attempt in $(seq 1 $MAX_RETRIES); do
                  echo "Lock attempt $lock_attempt of $MAX_RETRIES..."
                  
                  # Ëé∑ÂèñÂΩìÂâçÁâàÊú¨Âè∑
                  CURRENT_VERSION=$(echo "$QUEUE_DATA" | jq -r '.version // 1')
                  
                  # Â∞ùËØïËé∑ÂèñÈîÅ
                  UPDATED_QUEUE_DATA=$(echo "$QUEUE_DATA" | \
                    jq --arg run_id "${{ github.run_id }}" \
                    --arg new_version "$((CURRENT_VERSION + 1))" \
                    '.run_id = $run_id | .version = ($new_version | tonumber)')
                  
                  # ËÆ°ÁÆóÈòüÂàóÊï∞Èáè
                  UPDATED_TOTAL_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.queue | length // 0')
                  UPDATED_ISSUE_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "issue")) | length // 0')
                  UPDATED_WORKFLOW_COUNT=$(echo "$UPDATED_QUEUE_DATA" | jq '.queue | map(select(.trigger_type == "workflow_dispatch")) | length // 0')
                  
                  # Êõ¥Êñ∞ÈòüÂàóÁÆ°ÁêÜissue
                  UPDATED_BODY="## ÊûÑÂª∫ÈòüÂàóÁÆ°ÁêÜ\n\n**ÊúÄÂêéÊõ¥Êñ∞Êó∂Èó¥Ôºö** \$(date '+%Y-%m-%d %H:%M:%S')\n\n### ÂΩìÂâçÁä∂ÊÄÅ\n- **ÊûÑÂª∫ÈîÅÁä∂ÊÄÅÔºö** Âç†Áî® üîí (run_id: ${{ github.run_id }})\n- **ÂΩìÂâçÊûÑÂª∫Ôºö** ÈòüÂàóÈ¶ñ‰Ωç\n- **ÈîÅÊåÅÊúâËÄÖÔºö** ËøêË°åID: ${{ github.run_id }}\n- **ÁâàÊú¨Ôºö** $((CURRENT_VERSION + 1))\n\n### ÊûÑÂª∫ÈòüÂàó\n- **ÂΩìÂâçÊï∞ÈáèÔºö** $UPDATED_TOTAL_COUNT/5\n- **IssueËß¶ÂèëÔºö** $UPDATED_ISSUE_COUNT/3\n- **ÊâãÂä®Ëß¶ÂèëÔºö** $UPDATED_WORKFLOW_COUNT/5\n\n---\n\n### ÈòüÂàóÊï∞ÊçÆ\n\`\`\`json\n$UPDATED_QUEUE_DATA\n\`\`\`"
                  
                  if update_queue_issue "$QUEUE_MANAGER_ISSUE" "$UPDATED_BODY"; then
                    echo "‚úÖ Lock acquired successfully on attempt $lock_attempt"
                    break 2  # Ë∑≥Âá∫‰∏§Â±ÇÂæ™ÁéØ
                  else
                    echo "‚ùå Lock acquisition failed on attempt $lock_attempt"
                    if [ "$lock_attempt" -lt "$MAX_RETRIES" ]; then
                      echo "Retrying lock acquisition in $RETRY_DELAY seconds..."
                      sleep $RETRY_DELAY
                      
                      # ÈáçÊñ∞Ëé∑ÂèñÈòüÂàóÊï∞ÊçÆ
                      QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
                      QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
                      if [ -z "$QUEUE_DATA" ]; then
                        echo "‚ùå Failed to extract queue JSON during retry, aborting."
                        exit 1
                      fi
                      
                      # È™åËØÅJSONÊ†ºÂºè
                      if ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
                        echo "‚ùå Invalid JSON format in queue data during retry, aborting."
                        exit 1
                      fi
                      
                      # Âº∫Âà∂ÂçïË°åJSON
                      QUEUE_DATA=$(echo "$QUEUE_DATA" | jq -c .)
                    else
                      echo "Max lock retries reached, continuing without lock..."
                      break 2
                    fi
                  fi
                done
              elif [ "$LOCK_RUN_ID" = "${{ github.run_id }}" ]; then
                echo "‚úÖ Already holding lock, proceeding to build..."
                break
              else
                echo "Lock held by run_id: $LOCK_RUN_ID, waiting..."
                sleep 30
                continue
              fi
            else
              echo "Not at front of queue (position: $CURRENT_POSITION), waiting..."
              sleep 30
              continue
            fi
          done
          
          # Ê£ÄÊü•ÊòØÂê¶Ë∂ÖÊó∂
          if [ $(($(date +%s) - START_TIME)) -ge $TIMEOUT ]; then
            echo "Queue timeout after 6 hours"
            exit 1
          fi 