name: 03 - Queue Cleanup

on:
  workflow_call:

jobs:
  queue_cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Check and cleanup queue
        run: |
          source .github/workflows/shared/github-utils.sh
          
          echo "Starting automatic queue cleanup..."
          
          # 重试机制参数
          MAX_RETRIES=5
          RETRY_DELAY=10
          
          # 重试清理队列
          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $attempt of $MAX_RETRIES to cleanup queue..."
            
            QUEUE_MANAGER_ISSUE="1"
            QUEUE_MANAGER_CONTENT=$(get_queue_manager_content "$QUEUE_MANAGER_ISSUE")
            QUEUE_DATA=$(extract_queue_json "$QUEUE_MANAGER_CONTENT")
            
            # 如果解析JSON失败，直接重置
            if [ -z "$QUEUE_DATA" ] || ! echo "$QUEUE_DATA" | jq . > /dev/null 2>&1; then
              echo "❌ JSON parsing failed, resetting queue template"
              reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "JSON解析失败，重置为默认模板"
              echo "✅ Queue reset triggered"
              exit 0
            fi
            
            # 获取当前状态
            CURRENT_VERSION=$(echo "$QUEUE_DATA" | jq -r '.version // 1')
            LOCK_RUN_ID=$(echo "$QUEUE_DATA" | jq -r '.run_id // null')
            QUEUE=$(echo "$QUEUE_DATA" | jq -r '.queue // []')
            
            echo "Current version: $CURRENT_VERSION"
            echo "Lock run_id: $LOCK_RUN_ID"
            echo "Queue: $QUEUE"
            
            # 检查需要清理的项目
            NEED_CLEANUP=false
            CLEANUP_REASONS=()
            
            # 1. 检查锁超时（超过2小时）
            if [ "$LOCK_RUN_ID" != "null" ]; then
              LOCK_ISSUE_JOIN_TIME=$(echo "$QUEUE" | \
                jq -r --arg run_id "$LOCK_RUN_ID" \
                '.[] | select(.issue_number == $run_id) | .join_time // empty' 2>/dev/null || echo "")
              
              if [ -n "$LOCK_ISSUE_JOIN_TIME" ]; then
                JOIN_TIMESTAMP=$(date -d "$LOCK_ISSUE_JOIN_TIME" +%s 2>/dev/null || echo "0")
                CURRENT_TIMESTAMP=$(date +%s)
                LOCK_DURATION_HOURS=$(( (CURRENT_TIMESTAMP - JOIN_TIMESTAMP) / 3600 ))
                
                if [ "$LOCK_DURATION_HOURS" -ge 2 ]; then
                  NEED_CLEANUP=true
                  CLEANUP_REASONS+=("锁超时：已占用${LOCK_DURATION_HOURS}小时")
                  echo "❌ Lock timeout: ${LOCK_DURATION_HOURS} hours"
                fi
              else
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("锁异常：找不到锁持有时间")
                echo "❌ Lock anomaly: no join time found"
              fi
            fi
            
            # 2. 检查重复项
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              DUPLICATE_ITEMS=$(echo "$QUEUE" | \
                jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number' 2>/dev/null || echo "")
              
              if [ -n "$DUPLICATE_ITEMS" ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("队列重复：构建项目 $DUPLICATE_ITEMS 重复")
                echo "❌ Duplicate items: $DUPLICATE_ITEMS"
              fi
            fi
            
            # 3. 检查无效issue
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              INVALID_ISSUES=()
              for issue_number in $(echo "$QUEUE" | jq -r '.[].issue_number'); do
                ISSUE_RESPONSE=$(curl -s \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/issues/$issue_number")
                
                if echo "$ISSUE_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  INVALID_ISSUES+=("$issue_number")
                  echo "❌ Issue #$issue_number not found"
                fi
              done
              
              if [ ${#INVALID_ISSUES[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("无效issue：${INVALID_ISSUES[*]} 不存在")
                echo "❌ Invalid issues: ${INVALID_ISSUES[*]}"
              fi
            fi
            
            # 4. 检查已结束的runs
            if [ "$(echo "$QUEUE" | jq -r 'type')" = "array" ]; then
              EXPIRED_RUNS=()
              for run_id in $(echo "$QUEUE" | jq -r '.[] | select(.trigger_type == "workflow_dispatch") | .issue_number'); do
                # 检查workflow run是否存在且未完成
                RUN_RESPONSE=$(curl -s \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/runs/$run_id")
                
                if echo "$RUN_RESPONSE" | jq -e '.message' | grep -q "Not Found"; then
                  EXPIRED_RUNS+=("$run_id")
                  echo "❌ Run #$run_id not found"
                else
                  # 检查run状态：completed, cancelled, failure, skipped 都是已结束状态
                  RUN_STATUS=$(echo "$RUN_RESPONSE" | jq -r '.status // "unknown"')
                  RUN_CONCLUSION=$(echo "$RUN_RESPONSE" | jq -r '.conclusion // "unknown"')
                  
                  if [ "$RUN_STATUS" = "completed" ] || [ "$RUN_STATUS" = "cancelled" ] || [ "$RUN_STATUS" = "failure" ] || [ "$RUN_STATUS" = "skipped" ]; then
                    EXPIRED_RUNS+=("$run_id")
                    echo "❌ Run #$run_id ended with status: $RUN_STATUS, conclusion: $RUN_CONCLUSION"
                  fi
                fi
              done
              
              if [ ${#EXPIRED_RUNS[@]} -gt 0 ]; then
                NEED_CLEANUP=true
                CLEANUP_REASONS+=("已结束runs：${EXPIRED_RUNS[*]} 已完成/取消/失败/跳过或不存在")
                echo "❌ Expired runs: ${EXPIRED_RUNS[*]}"
              fi
            fi
            
            # 执行清理
            if [ "$NEED_CLEANUP" = true ]; then
              echo "Performing queue cleanup..."
              echo "Cleanup reasons: ${CLEANUP_REASONS[*]}"
              
              # 构建清理原因文本
              CLEANUP_REASON_TEXT=""
              for reason in "${CLEANUP_REASONS[@]}"; do
                CLEANUP_REASON_TEXT="${CLEANUP_REASON_TEXT}• $reason\n"
              done
              
              # 使用工具函数清理队列数据
              if cleanup_queue_data "$QUEUE_MANAGER_ISSUE" "$CLEANUP_REASON_TEXT" "$CURRENT_VERSION" "$QUEUE_DATA" "${INVALID_ISSUES[@]}" "${EXPIRED_RUNS[@]}"; then
                echo "✅ Queue cleanup successful on attempt $attempt"
                break
              else
                echo "❌ Queue cleanup failed on attempt $attempt"
                if [ "$attempt" -lt "$MAX_RETRIES" ]; then
                  echo "Retrying in $RETRY_DELAY seconds..."
                  sleep $RETRY_DELAY
                else
                  echo "Max retries reached, triggering queue reset..."
                  reset_queue_to_default "$QUEUE_MANAGER_ISSUE" "清理失败，重置队列"
                  break
                fi
              fi
            else
              echo "No cleanup needed, queue is healthy"
              break
            fi
          done