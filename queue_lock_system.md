# 队列锁系统说明

## 系统概述

新的队列系统实现了真正的构建锁机制，确保同一时间只有一个构建流程在运行。

## 核心特性

### 🔒 **构建锁机制**
- **锁状态**：空闲 🔓 / 占用 🔒
- **锁持有者**：记录当前持有锁的用户
- **当前构建**：记录正在构建的issue编号

### 📋 **队列管理**
- **Issue队列**：最多3个issue等待
- **Workflow队列**：最多5个workflow等待
- **总队列限制**：最多5个总项目

## 工作流程

### 1. **加入队列**
```
Issue/Workflow触发 → 加入对应队列 → 更新队列状态
```

### 2. **等待队列位置**
```
检查队列位置 → 如果不是首位 → 等待5分钟 → 重新检查
```

### 3. **等待构建锁**
```
到达首位 → 检查构建锁 → 如果锁被占用 → 等待锁释放
```

### 4. **获取构建锁**
```
锁空闲 → 尝试获取锁 → 更新锁状态 → 开始构建
```

### 5. **释放构建锁**
```
构建完成 → finish阶段 → 释放锁 → 下一个项目可以开始
```

## 队列数据结构

```json
{
  "issue_queue": [
    {
      "issue_number": "58",
      "issue_title": "构建请求",
      "user": "username",
      "join_time": "2025-07-12T06:00:00Z"
    }
  ],
  "workflow_queue": [],
  "current_build": "58",
  "lock_holder": "username"
}
```

## Issue #1 显示格式

```markdown
## 构建队列管理

**最后更新时间：** 2025-07-12 06:00:00

### 当前状态
- **构建锁状态：** 占用 🔒
- **当前构建：** 58
- **锁持有者：** username

### Issue队列 (最多3个)
- 当前数量：1/3

### Workflow队列 (最多5个)
- 当前数量：0/5

### 总队列 (最多5个)
- 当前数量：1/5

---

### 队列数据
```json
{"issue_queue":[...],"workflow_queue":[],"current_build":"58","lock_holder":"username"}
```
```

## 状态说明

### 🔓 **空闲状态**
- `current_build`: null
- `lock_holder`: null
- 下一个队列项目可以立即开始构建

### 🔒 **占用状态**
- `current_build`: 当前构建的issue编号
- `lock_holder`: 持有锁的用户
- 其他项目需要等待锁释放

## 等待机制

### 队列位置等待
- 检查是否到达队列首位
- 每5分钟更新一次状态
- 显示当前队列位置和预计等待时间

### 构建锁等待
- 到达首位后检查构建锁
- 如果锁被占用，等待锁释放
- 显示当前锁持有者和构建项目

## 锁获取机制

### 原子性操作
1. 重新获取最新队列数据
2. 检查锁是否仍然空闲
3. 如果空闲，立即更新锁状态
4. 如果被占用，继续等待

### 竞争处理
- 多个项目同时尝试获取锁时
- 只有第一个成功获取的项目会继续
- 其他项目会继续等待

## 锁释放机制

### 自动释放
- 在finish阶段自动释放锁
- 更新锁状态为空闲
- 通知下一个队列项目

### 异常处理
- 如果工作流异常终止，锁可能不会自动释放
- 需要手动检查Issue #1并重置锁状态

## 使用建议

### 1. **监控队列状态**
- 定期检查Issue #1的锁状态
- 关注队列等待时间

### 2. **处理异常情况**
- 如果锁长时间被占用但无构建进行
- 手动重置锁状态：将`current_build`和`lock_holder`设为null

### 3. **队列管理**
- 定期清理长时间等待的队列项目
- 监控队列长度，避免队列过满

## 优势

1. **真正的互斥**：确保只有一个构建流程运行
2. **公平排队**：FIFO队列，先到先服务
3. **状态透明**：实时显示队列和锁状态
4. **自动管理**：自动获取和释放锁
5. **异常恢复**：支持手动重置锁状态 