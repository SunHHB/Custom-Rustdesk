# 双锁架构设计文档

## 📋 概述

本文档描述了Custom Rustdesk构建系统的双锁架构设计，该设计用于管理GitHub Actions工作流中的队列和构建操作，确保数据一致性和系统并发性能。

## 🎯 设计目标

### 核心目标
- **数据一致性** - 确保队列数据在并发环境下的正确性
- **高并发性能** - 最大化系统吞吐量，减少锁竞争
- **简单易维护** - 降低系统复杂度，提高可维护性
- **操作安全** - 防止竞态条件和数据损坏

### 性能要求
- **快速操作**（队列管理）：毫秒级响应
- **慢速操作**（构建任务）：支持70分钟长时间运行
- **并发支持**：多个任务同时进行队列操作

## 🔒 双锁架构设计

### 锁的定义

#### 1. Issue锁 (issue_lock)
- **作用**：管理Issue #1的数据一致性
- **范围**：保护所有队列数据的读写操作
- **特点**：轻量级，获取和释放速度快

#### 2. Build锁 (build_lock)
- **作用**：管理构建操作的互斥访问
- **范围**：确保同一时间只有一个构建任务运行
- **特点**：重量级，持有时间长

### 锁的状态管理

每个锁在Issue #1中维护以下状态：
```json
{
  "issue_locked_by": "run_id或null",
  "issue_lock_version": "版本号",
  "build_locked_by": "run_id或null", 
  "build_lock_version": "版本号",
  "version": "整体版本号"
}
```

## ⚡ 快速操作策略

### 适用场景
- 加入队列
- 检查队列状态
- 从队列中移除
- 清理队列
- 查询队列信息

### 锁使用模式
```
获取issue锁 → 完成队列操作 → 释放issue锁
```

### 优势
- **操作快速**：队列操作通常在毫秒级完成
- **锁竞争少**：只使用一个锁，减少竞争
- **逻辑简单**：获取锁、操作、释放锁的简单流程

### 示例：加入队列
```bash
# 1. 获取issue锁
acquire_lock "issue" "$build_id"

# 2. 检查队列状态
load_queue_data
check_queue_status

# 3. 添加到队列
update_queue_data

# 4. 释放issue锁
release_lock "issue" "$build_id"
```

## 🐌 慢速操作策略

### 适用场景
- 获取构建权限
- 执行构建任务
- 释放构建权限

### 锁使用模式
```
获取issue锁 → 获取build锁 → 释放issue锁 → 长时间构建 → 获取issue锁 → 释放build锁 → 释放issue锁
```

### 优势
- **避免长时间阻塞**：获取build锁后立即释放issue锁
- **最大化并发**：其他任务可以使用issue锁进行队列操作
- **保护构建过程**：build锁确保只有一个构建任务运行

### 示例：获取构建权限
```bash
# 1. 获取issue锁
acquire_lock "issue" "$build_id"

# 2. 获取build锁
acquire_lock "build" "$build_id"

# 3. 立即释放issue锁（避免长时间阻塞）
release_lock "issue" "$build_id"

# 4. 开始长时间构建（70分钟）
# ... 构建过程 ...

# 5. 构建完成后，重新获取issue锁
acquire_lock "issue" "$build_id"

# 6. 释放build锁
release_lock "build" "$build_id"

# 7. 释放issue锁
release_lock "issue" "$build_id"
```

## 🔄 完整工作流程

### 阶段1：加入队列
```
触发工作流 → 获取issue锁 → 检查队列状态 → 添加到队列 → 释放issue锁 → 返回队列位置
```

### 阶段2：等待构建权限
```
检查队列位置 → 等待build锁释放 → 检查是否轮到我们
```

### 阶段3：获取构建权限
```
获取issue锁 → 获取build锁 → 释放issue锁 → 开始构建
```

### 阶段4：构建完成
```
获取issue锁 → 释放build锁 → 从队列中移除 → 释放issue锁
```

## 📊 性能分析

### 并发性能
| 操作类型 | 锁使用 | 并发度 | 性能特点 |
|----------|--------|--------|----------|
| 队列操作 | 仅issue锁 | 高 | 快速响应，低延迟 |
| 构建操作 | issue锁 + build锁 | 中 | 长时间运行，高吞吐 |

### 锁竞争分析
- **Issue锁竞争**：仅在队列操作时发生，竞争程度低
- **Build锁竞争**：仅在获取构建权限时发生，竞争程度中
- **整体竞争**：通过及时释放issue锁，大幅降低竞争

### 响应时间
- **队列操作**：< 100ms
- **构建权限获取**：< 1s
- **构建任务**：70分钟（独立运行）

## 🛡️ 安全性保障

### 数据一致性
- **Issue锁保护**：所有队列数据修改都在issue锁保护下进行
- **版本控制**：使用版本号防止并发修改冲突
- **原子操作**：锁的获取和释放是原子操作

### 死锁预防
- **固定顺序**：总是先获取issue锁，再获取build锁
- **及时释放**：获取build锁后立即释放issue锁
- **超时机制**：锁获取有超时限制，防止无限等待

### 错误处理
- **锁获取失败**：自动重试，有最大重试次数
- **锁释放失败**：记录错误日志，不影响后续操作
- **数据损坏**：使用默认数据恢复，确保系统可用

## 🔧 实现细节

### 锁获取算法
```bash
acquire_lock() {
  while (未超时) {
    load_queue_data()
    if (锁可用 || 锁被自己持有) {
      if (版本号匹配) {
        更新锁状态
        if (更新成功) {
          return 成功
        }
      }
    }
    等待5秒
  }
  return 失败
}
```

### 锁释放算法
```bash
release_lock() {
  load_queue_data()
  if (锁被自己持有) {
    清除锁状态
    if (更新成功) {
      return 成功
    }
  }
  return 失败
}
```

### 数据更新机制
```bash
update_queue_data() {
  生成新的issue body
  调用GitHub API更新issue
  更新本地缓存
}
```

## 📈 与三锁架构对比

| 特性 | 三锁架构 | 双锁架构 |
|------|----------|----------|
| **锁数量** | 3个 | 2个 |
| **复杂度** | 高 | 低 |
| **维护成本** | 高 | 低 |
| **并发性能** | 中等 | 高 |
| **错误概率** | 高 | 低 |
| **扩展性** | 中等 | 高 |

## 🎯 最佳实践

### 锁使用原则
1. **最小化锁持有时间**：尽快释放锁
2. **避免嵌套锁**：不要在一个锁保护下获取另一个锁
3. **统一锁顺序**：总是按相同顺序获取锁
4. **及时释放锁**：操作完成后立即释放锁

### 错误处理原则
1. **优雅降级**：锁获取失败时提供备选方案
2. **重试机制**：临时失败时自动重试
3. **超时控制**：避免无限等待
4. **日志记录**：详细记录锁操作日志

### 性能优化原则
1. **批量操作**：尽可能批量处理队列操作
2. **缓存机制**：缓存频繁访问的数据
3. **异步处理**：非关键操作使用异步处理
4. **资源清理**：及时清理过期数据

## 🔮 未来扩展

### 可能的扩展方向
1. **多队列支持**：支持不同类型的构建队列
2. **优先级队列**：支持任务优先级
3. **分布式锁**：支持多实例部署
4. **监控告警**：实时监控锁状态和性能

### 扩展考虑
- **向后兼容**：新功能不影响现有功能
- **性能影响**：扩展不显著影响性能
- **复杂度控制**：保持架构简洁
- **测试覆盖**：确保扩展功能的稳定性

## 📝 总结

双锁架构通过简化的设计，在保证数据一致性的同时，显著提升了系统的并发性能和可维护性。该架构特别适合具有快速队列操作和慢速构建任务特点的构建系统，是一个平衡性能、安全性和复杂度的优秀解决方案。

### 核心价值
- **简化架构**：从三锁简化为双锁，降低复杂度
- **提升性能**：优化锁使用策略，最大化并发
- **增强安全**：确保数据一致性和操作安全
- **易于维护**：清晰的逻辑和简单的实现

该架构为Custom Rustdesk构建系统提供了稳定、高效、可扩展的并发控制机制。 