# 队列自动清理机制

## 概述

新的队列系统在每次进入排队阶段时，会首先进行自动清理，处理各种异常情况导致的锁卡住和队列状态异常。

## 清理触发时机

- **每次进入队列阶段**：在检查队列状态之前自动执行
- **主动检测**：无需手动触发，系统自动识别异常
- **预防性清理**：在问题发生前就进行修复

## 检测的异常类型

### 1. 🔒 **锁状态异常**

#### 锁不一致
- **有构建项目但无持有者**：`current_build`有值但`lock_holder`为null
- **有持有者但无构建项目**：`lock_holder`有值但`current_build`为null

#### 锁超时
- **长时间占用**：锁持有时间超过2小时
- **自动释放**：防止锁永久卡住

### 2. 🔄 **队列重复项**

#### Issue队列重复
- 同一个issue在队列中出现多次
- 自动保留第一个，移除后续重复项

#### Workflow队列重复
- 同一个workflow在队列中出现多次
- 自动保留第一个，移除后续重复项

### 3. ✅ **已完成构建未释放锁**

#### 构建完成但锁未释放
- 当前构建的issue已不在队列中
- 但锁仍然被占用
- 自动释放锁

## 清理过程

### 1. **状态检查**
```bash
# 检查锁状态
CURRENT_BUILD=$(echo "$QUEUE_DATA" | jq -r '.current_build')
LOCK_HOLDER=$(echo "$QUEUE_DATA" | jq -r '.lock_holder')

# 检查队列重复
DUPLICATE_ISSUES=$(echo "$ISSUE_QUEUE" | \
  jq -r 'group_by(.issue_number) | .[] | select(length > 1) | .[0].issue_number')
```

### 2. **锁超时检测**
```bash
# 计算锁持有时间
JOIN_TIMESTAMP=$(date -d "$LOCK_ISSUE_JOIN_TIME" +%s)
CURRENT_TIMESTAMP=$(date +%s)
LOCK_DURATION=$((CURRENT_TIMESTAMP - JOIN_TIMESTAMP))
LOCK_DURATION_HOURS=$((LOCK_DURATION / 3600))

if [ "$LOCK_DURATION_HOURS" -ge 2 ]; then
  # 锁超时，需要清理
fi
```

### 3. **执行清理**
```json
{
  "issue_queue": [去重后的issue队列],
  "workflow_queue": [去重后的workflow队列],
  "current_build": null,
  "lock_holder": null
}
```

## 清理记录

### Issue #1 显示格式
```markdown
## 构建队列管理

**最后更新时间：** 2025-07-12 06:00:00

### 当前状态
- **构建锁状态：** 空闲 🔓 (已清理)
- **当前构建：** 无
- **锁持有者：** 无

### Issue队列 (最多3个)
- 当前数量：1/3

### Workflow队列 (最多5个)
- 当前数量：0/5

### 总队列 (最多5个)
- 当前数量：1/5

---

### 清理记录
**清理时间：** 2025-07-12 06:00:00
**清理原因：**
• 锁超时：已占用3小时
• 队列重复：Issue 58 重复
• 构建完成：Issue 57 已不在队列中

### 队列数据
```json
{"issue_queue":[...],"workflow_queue":[],"current_build":null,"lock_holder":null}
```
```

## 清理效果

### 1. **自动修复**
- 重置异常锁状态
- 移除队列重复项
- 释放超时锁

### 2. **状态恢复**
- 队列状态恢复正常
- 锁状态变为空闲
- 新的构建可以正常进行

### 3. **透明记录**
- 记录清理原因和时间
- 便于问题追踪
- 提供操作历史

## 优势

### 🔧 **自动修复**
- 无需手动干预
- 系统自动识别和修复问题
- 减少人工维护成本

### 🛡️ **预防性保护**
- 在问题发生前就进行检测
- 防止锁永久卡住
- 确保队列正常运行

### 📊 **状态透明**
- 详细的清理记录
- 清晰的问题描述
- 便于监控和调试

### ⚡ **高效处理**
- 快速识别异常
- 立即执行清理
- 最小化影响时间

## 使用建议

### 1. **监控清理记录**
- 定期检查Issue #1的清理记录
- 关注清理频率和原因
- 识别潜在的系统问题

### 2. **分析清理原因**
- 如果频繁出现锁超时，可能需要调整超时时间
- 如果经常有重复项，可能需要检查触发逻辑
- 如果构建完成但锁未释放，可能需要检查finish阶段

### 3. **优化系统**
- 根据清理记录优化工作流
- 减少异常情况的发生
- 提高系统稳定性

## 配置参数

### 锁超时时间
- **当前设置**：2小时
- **可调整**：根据实际构建时间调整
- **建议**：设置为正常构建时间的1.5-2倍

### 清理检查频率
- **当前设置**：每次进入队列阶段
- **频率**：每次触发工作流时检查
- **影响**：最小化，只在需要时执行清理

## 故障排除

### 如果清理后仍有问题
1. 检查Issue #1的清理记录
2. 确认清理是否成功执行
3. 手动检查队列数据格式
4. 必要时手动重置锁状态

### 手动重置锁状态
如果自动清理失败，可以手动编辑Issue #1：
```json
{
  "issue_queue": [...],
  "workflow_queue": [...],
  "current_build": null,
  "lock_holder": null
}
``` 